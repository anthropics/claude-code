/**
 * Enhanced Error Handler Module for Claude Neural Framework
 * 
 * This module provides a standardized way to handle errors and logging
 * across the framework, with special support for the SAAR.sh script.
 * 
 * Features:
 * - Standardized error classification
 * - Consistent error logging format
 * - Error recovery suggestions
 * - Shell-script compatible error handling
 * - Multi-level logging
 */

const fs = require('fs');
const path = require('path');
const os = require('os');

// Error types
const ErrorTypes = {
  VALIDATION: 'validation',
  CONFIGURATION: 'configuration',
  DEPENDENCY: 'dependency',
  PERMISSION: 'permission',
  NETWORK: 'network',
  EXECUTION: 'execution',
  TIMEOUT: 'timeout',
  UNKNOWN: 'unknown'
};

// Error severity levels
const SeverityLevels = {
  INFO: 'info',
  WARNING: 'warning',
  ERROR: 'error',
  CRITICAL: 'critical',
  FATAL: 'fatal'
};

// Log levels
const LogLevels = {
  DEBUG: 'debug',
  INFO: 'info',
  WARN: 'warn', 
  ERROR: 'error',
  NONE: 'none'
};

// ANSI colors for console output
const Colors = {
  RESET: '\x1b[0m',
  RED: '\x1b[31m',
  GREEN: '\x1b[32m',
  YELLOW: '\x1b[33m',
  BLUE: '\x1b[34m',
  MAGENTA: '\x1b[35m',
  CYAN: '\x1b[36m',
  WHITE: '\x1b[37m',
  BOLD: '\x1b[1m',
  UNDERLINE: '\x1b[4m'
};

/**
 * Custom Error class for Claude Neural Framework
 */
class FrameworkError extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = 'FrameworkError';
    this.type = options.type || ErrorTypes.UNKNOWN;
    this.severity = options.severity || SeverityLevels.ERROR;
    this.errorCode = options.errorCode || 'ERR_UNKNOWN';
    this.details = options.details || null;
    this.recoverable = options.recoverable !== undefined ? options.recoverable : true;
    this.recovery = options.recovery || null;
    this.originalError = options.originalError || null;
    this.component = options.component || 'unknown';
    this.timestamp = new Date();
    
    // Capture stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  /**
   * Format error for display
   */
  toString() {
    let output = `[${this.severity.toUpperCase()}] ${this.errorCode}: ${this.message}`;
    
    if (this.details) {
      output += `\nDetails: ${this.details}`;
    }
    
    if (this.recovery) {
      output += `\nRecovery: ${this.recovery}`;
    }
    
    return output;
  }
  
  /**
   * Format error for shell scripts
   */
  toShellString() {
    const severity = this.severity.toUpperCase();
    let color;
    
    switch (this.severity) {
      case SeverityLevels.INFO:
        color = Colors.BLUE;
        break;
      case SeverityLevels.WARNING:
        color = Colors.YELLOW;
        break;
      case SeverityLevels.ERROR:
        color = Colors.RED;
        break;
      case SeverityLevels.CRITICAL:
      case SeverityLevels.FATAL:
        color = `${Colors.RED}${Colors.BOLD}`;
        break;
      default:
        color = Colors.RESET;
    }
    
    let output = `${color}[${severity}]${Colors.RESET} ${this.message}`;
    
    if (this.recovery) {
      output += `\n${Colors.GREEN}${Colors.BOLD}Recovery:${Colors.RESET} ${this.recovery}`;
    }
    
    return output;
  }
  
  /**
   * Convert to JSON
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      type: this.type,
      severity: this.severity,
      errorCode: this.errorCode,
      details: this.details,
      recoverable: this.recoverable,
      recovery: this.recovery,
      component: this.component,
      timestamp: this.timestamp.toISOString(),
      stack: this.stack
    };
  }
}

/**
 * ErrorHandler class
 */
class ErrorHandler {
  constructor(options = {}) {
    this.options = {
      logDirectory: path.join(os.homedir(), '.claude', 'logs'),
      logFile: 'framework.log',
      errorLogFile: 'error.log',
      logLevel: LogLevels.INFO,
      includeTimestamp: true,
      includeStackTrace: true,
      exitOnFatal: true,
      shellMode: false,
      ...options
    };
    
    // Create log directory if it doesn't exist
    if (!fs.existsSync(this.options.logDirectory)) {
      try {
        fs.mkdirSync(this.options.logDirectory, { recursive: true });
      } catch (error) {
        console.error(`Failed to create log directory: ${error.message}`);
      }
    }
  }
  
  /**
   * Handle an error
   */
  handleError(error, options = {}) {
    // Convert regular Error to FrameworkError if needed
    const frameworkError = error instanceof FrameworkError 
      ? error 
      : this._convertToFrameworkError(error, options);
    
    // Log the error
    this._logError(frameworkError);
    
    // Display error message
    if (this.options.shellMode) {
      console.error(frameworkError.toShellString());
    } else {
      console.error(frameworkError.toString());
    }
    
    // Exit process on fatal errors if configured
    if (
      this.options.exitOnFatal && 
      (frameworkError.severity === SeverityLevels.FATAL || 
       options.exitProcess === true)
    ) {
      process.exit(options.exitCode || 1);
    }
    
    return frameworkError;
  }
  
  /**
   * Log a message
   */
  log(level, message, component = 'system') {
    const levels = {
      [LogLevels.DEBUG]: 0,
      [LogLevels.INFO]: 1,
      [LogLevels.WARN]: 2,
      [LogLevels.ERROR]: 3,
      [LogLevels.NONE]: 4
    };
    
    // Skip if log level is not high enough
    if (levels[level] < levels[this.options.logLevel]) {
      return;
    }
    
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level.toUpperCase()}] [${component}] ${message}`;
    
    // Write to log file
    const logFilePath = path.join(this.options.logDirectory, this.options.logFile);
    
    try {
      fs.appendFileSync(logFilePath, logEntry + '\n');
    } catch (error) {
      console.error(`Failed to write to log file: ${error.message}`);
    }
    
    // Output to console if in shell mode or for warnings and errors
    if (
      this.options.shellMode || 
      level === LogLevels.WARN || 
      level === LogLevels.ERROR
    ) {
      let color;
      
      switch (level) {
        case LogLevels.DEBUG:
          color = Colors.BLUE;
          break;
        case LogLevels.INFO:
          color = Colors.GREEN;
          break;
        case LogLevels.WARN:
          color = Colors.YELLOW;
          break;
        case LogLevels.ERROR:
          color = Colors.RED;
          break;
        default:
          color = Colors.RESET;
      }
      
      const formattedEntry = this.options.includeTimestamp
        ? `${color}[${level.toUpperCase()}]${Colors.RESET} [${component}] ${message}`
        : `${color}[${level.toUpperCase()}]${Colors.RESET} ${message}`;
      
      console.log(formattedEntry);
    }
  }
  
  /**
   * Generate a shell-compatible error handler script
   */
  generateShellErrorHandler() {
    return `
# Error handling functions for shell scripts
# Generated by Claude Neural Framework ErrorHandler

# Error types
ERROR_VALIDATION=1
ERROR_CONFIGURATION=2
ERROR_DEPENDENCY=3
ERROR_PERMISSION=4
ERROR_NETWORK=5
ERROR_EXECUTION=6
ERROR_TIMEOUT=7
ERROR_UNKNOWN=99

# Log levels
LOG_DEBUG=0
LOG_INFO=1
LOG_WARN=2
LOG_ERROR=3
LOG_NONE=4

# Colors
COLOR_RED='\\033[0;31m'
COLOR_GREEN='\\033[0;32m'
COLOR_YELLOW='\\033[0;33m'
COLOR_BLUE='\\033[0;34m'
COLOR_MAGENTA='\\033[0;35m'
COLOR_CYAN='\\033[0;36m'
COLOR_RESET='\\033[0m'
COLOR_BOLD='\\033[1m'

# Log directory
LOG_DIRECTORY="${this.options.logDirectory}"
LOG_FILE="${this.options.logFile}"
ERROR_LOG_FILE="${this.options.errorLogFile}"

# Create log directory if it doesn't exist
mkdir -p "$LOG_DIRECTORY"

# Current log level
LOG_LEVEL=$LOG_INFO

# Log a message
log() {
  local level=$1
  local message=$2
  local component=${3:-"system"}
  
  # Skip if log level is too low
  if [ "$level" -lt "$LOG_LEVEL" ]; then
    return 0
  fi
  
  # Format log entry
  local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
  local log_entry="[$timestamp] "
  
  case $level in
    $LOG_DEBUG)
      log_entry+="[DEBUG] [$component] $message"
      local color_message="${COLOR_BLUE}[DEBUG]${COLOR_RESET} [$component] $message"
      ;;
    $LOG_INFO)
      log_entry+="[INFO] [$component] $message"
      local color_message="${COLOR_GREEN}[INFO]${COLOR_RESET} [$component] $message"
      ;;
    $LOG_WARN)
      log_entry+="[WARN] [$component] $message"
      local color_message="${COLOR_YELLOW}[WARN]${COLOR_RESET} [$component] $message"
      ;;
    $LOG_ERROR)
      log_entry+="[ERROR] [$component] $message"
      local color_message="${COLOR_RED}[ERROR]${COLOR_RESET} [$component] $message"
      ;;
    *)
      log_entry+="[UNKNOWN] [$component] $message"
      local color_message="[UNKNOWN] [$component] $message"
      ;;
  esac
  
  # Write to log file
  echo "$log_entry" >> "$LOG_DIRECTORY/$LOG_FILE"
  
  # Write to error log if it's an error
  if [ "$level" -ge "$LOG_ERROR" ]; then
    echo "$log_entry" >> "$LOG_DIRECTORY/$ERROR_LOG_FILE"
  fi
  
  # Output to console
  echo -e "$color_message"
}

# Handle an error
handle_error() {
  local message=$1
  local error_type=${2:-$ERROR_UNKNOWN}
  local component=${3:-"system"}
  local recovery=${4:-""}
  
  # Log the error
  log $LOG_ERROR "$message" "$component"
  
  # Display recovery instructions if available
  if [ -n "$recovery" ]; then
    echo -e "${COLOR_GREEN}${COLOR_BOLD}Recovery:${COLOR_RESET} $recovery"
  fi
  
  return $error_type
}

# Fatal error handler - exits the script
fatal_error() {
  local message=$1
  local error_type=${2:-$ERROR_UNKNOWN}
  local component=${3:-"system"}
  local recovery=${4:-""}
  
  # Log the error
  log $LOG_ERROR "$message" "$component"
  
  # Display in red bold
  echo -e "${COLOR_RED}${COLOR_BOLD}[FATAL ERROR]${COLOR_RESET} $message"
  
  # Display recovery instructions if available
  if [ -n "$recovery" ]; then
    echo -e "${COLOR_GREEN}${COLOR_BOLD}Recovery:${COLOR_RESET} $recovery"
  fi
  
  # Exit with error code
  exit $error_type
}

# Check a command result
check_result() {
  local result=$1
  local error_message=${2:-"Command failed"}
  local component=${3:-"system"}
  local recovery=${4:-""}
  
  if [ $result -ne 0 ]; then
    handle_error "$error_message (Exit code: $result)" $ERROR_EXECUTION "$component" "$recovery"
    return $result
  fi
  
  return 0
}

# Set log level
set_log_level() {
  LOG_LEVEL=$1
}

# Enable debugging
enable_debug() {
  set_log_level $LOG_DEBUG
  log $LOG_DEBUG "Debug logging enabled" "system"
}

# Setup error trap
setup_error_trap() {
  trap 'fatal_error "Unexpected error on line $LINENO. Command: $BASH_COMMAND" $ERROR_UNKNOWN "system" "Check the log for details"' ERR
}
`;
  }
  
  /**
   * Create an error builder object for fluent API
   */
  createError() {
    return new ErrorBuilder(this);
  }
  
  /**
   * Convert a regular Error to a FrameworkError
   */
  _convertToFrameworkError(error, options = {}) {
    // If it's already a FrameworkError, return it
    if (error instanceof FrameworkError) {
      return error;
    }
    
    // Extract info from regular Error
    const message = error.message || 'Unknown error';
    const type = options.type || ErrorTypes.UNKNOWN;
    const severity = options.severity || SeverityLevels.ERROR;
    const errorCode = options.errorCode || 'ERR_UNKNOWN';
    const component = options.component || 'unknown';
    
    // Create new FrameworkError
    return new FrameworkError(message, {
      type,
      severity,
      errorCode,
      component,
      details: options.details || null,
      recovery: options.recovery || null,
      originalError: error
    });
  }
  
  /**
   * Log an error
   */
  _logError(error) {
    // Create log entry
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      type: error.type,
      severity: error.severity,
      errorCode: error.errorCode,
      message: error.message,
      details: error.details,
      component: error.component,
      stack: this.options.includeStackTrace ? error.stack : undefined
    };
    
    // Convert to string for log file
    const logString = `[${timestamp}] [${error.severity.toUpperCase()}] [${error.errorCode}] [${error.component}] ${error.message}${error.details ? ' | ' + error.details : ''}${this.options.includeStackTrace ? '\n' + error.stack : ''}`;
    
    // Write to log file
    const logFilePath = path.join(this.options.logDirectory, this.options.errorLogFile);
    
    try {
      fs.appendFileSync(logFilePath, logString + '\n\n');
    } catch (err) {
      console.error(`Failed to write to error log file: ${err.message}`);
    }
    
    // Also write to general log
    const generalLogPath = path.join(this.options.logDirectory, this.options.logFile);
    
    try {
      fs.appendFileSync(generalLogPath, logString + '\n');
    } catch (err) {
      console.error(`Failed to write to general log file: ${err.message}`);
    }
  }
}

/**
 * Fluent API for creating errors
 */
class ErrorBuilder {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
    this.options = {
      type: ErrorTypes.UNKNOWN,
      severity: SeverityLevels.ERROR,
      errorCode: 'ERR_UNKNOWN',
      component: 'unknown',
      details: null,
      recovery: null,
      exitProcess: false,
      exitCode: 1
    };
  }
  
  /**
   * Set error type
   */
  type(type) {
    this.options.type = type;
    return this;
  }
  
  /**
   * Set error severity
   */
  severity(severity) {
    this.options.severity = severity;
    return this;
  }
  
  /**
   * Set error code
   */
  code(code) {
    this.options.errorCode = code;
    return this;
  }
  
  /**
   * Set component
   */
  component(component) {
    this.options.component = component;
    return this;
  }
  
  /**
   * Set details
   */
  details(details) {
    this.options.details = details;
    return this;
  }
  
  /**
   * Set recovery instructions
   */
  recovery(recovery) {
    this.options.recovery = recovery;
    return this;
  }
  
  /**
   * Set recoverable flag
   */
  recoverable(recoverable) {
    this.options.recoverable = recoverable;
    return this;
  }
  
  /**
   * Set exit process flag
   */
  exitProcess(exitProcess = true) {
    this.options.exitProcess = exitProcess;
    return this;
  }
  
  /**
   * Set exit code
   */
  exitCode(exitCode) {
    this.options.exitCode = exitCode;
    return this;
  }
  
  /**
   * Create and throw the error
   */
  throw(message) {
    const error = new FrameworkError(message, this.options);
    throw error;
  }
  
  /**
   * Create and handle the error
   */
  create(message) {
    const error = new FrameworkError(message, this.options);
    return this.errorHandler.handleError(error, this.options);
  }
  
  /**
   * Create a validation error
   */
  validation(message) {
    return this.type(ErrorTypes.VALIDATION)
      .code('ERR_VALIDATION')
      .create(message);
  }
  
  /**
   * Create a configuration error
   */
  configuration(message) {
    return this.type(ErrorTypes.CONFIGURATION)
      .code('ERR_CONFIGURATION')
      .create(message);
  }
  
  /**
   * Create a dependency error
   */
  dependency(message) {
    return this.type(ErrorTypes.DEPENDENCY)
      .code('ERR_DEPENDENCY')
      .create(message);
  }
  
  /**
   * Create a permission error
   */
  permission(message) {
    return this.type(ErrorTypes.PERMISSION)
      .code('ERR_PERMISSION')
      .create(message);
  }
  
  /**
   * Create a network error
   */
  network(message) {
    return this.type(ErrorTypes.NETWORK)
      .code('ERR_NETWORK')
      .create(message);
  }
  
  /**
   * Create an execution error
   */
  execution(message) {
    return this.type(ErrorTypes.EXECUTION)
      .code('ERR_EXECUTION')
      .create(message);
  }
  
  /**
   * Create a timeout error
   */
  timeout(message) {
    return this.type(ErrorTypes.TIMEOUT)
      .code('ERR_TIMEOUT')
      .create(message);
  }
  
  /**
   * Create a fatal error (exits process by default)
   */
  fatal(message) {
    return this.type(ErrorTypes.UNKNOWN)
      .severity(SeverityLevels.FATAL)
      .code('ERR_FATAL')
      .recoverable(false)
      .exitProcess()
      .create(message);
  }
}

// Create singleton instance
const defaultErrorHandler = new ErrorHandler();

// Export classes, constants, and default instance
module.exports = {
  ErrorHandler,
  FrameworkError,
  ErrorBuilder,
  ErrorTypes,
  SeverityLevels,
  LogLevels,
  defaultErrorHandler
};

// Add global error handler if in top-level Node.js module
if (require.main === module) {
  process.on('uncaughtException', (error) => {
    defaultErrorHandler.handleError(error, {
      component: 'uncaughtException',
      severity: SeverityLevels.FATAL,
      exitProcess: true
    });
  });
  
  process.on('unhandledRejection', (reason, promise) => {
    const error = reason instanceof Error ? reason : new Error(String(reason));
    defaultErrorHandler.handleError(error, {
      component: 'unhandledRejection',
      severity: SeverityLevels.ERROR
    });
  });
  
  console.log('Global error handlers installed');
}