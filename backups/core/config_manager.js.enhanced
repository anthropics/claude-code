/**
 * Unified Configuration Management Module for Claude Neural Framework
 * 
 * This module provides a centralized way to manage configuration across
 * the framework, with validation, environment variable support, and
 * persistence.
 * 
 * Features:
 * - Configuration schema validation
 * - Environment variable override
 * - Configuration persistence
 * - Default fallback values
 * - Nested configuration support
 * - Configuration change events
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { EventEmitter } = require('events');

// Get error handler if available
let errorHandler;
try {
  errorHandler = require('../error/error_handler').defaultErrorHandler;
} catch (error) {
  // Create simple logging function if error handler not available
  errorHandler = {
    log: (level, message, component) => {
      console.log(`[${level.toUpperCase()}] [${component}] ${message}`);
    },
    handleError: (error) => {
      console.error(`[ERROR] ${error.message}`);
      return error;
    }
  };
}

/**
 * Helper to check if a value is a plain object
 */
function isPlainObject(value) {
  return typeof value === 'object' 
    && value !== null 
    && !Array.isArray(value) 
    && Object.prototype.toString.call(value) === '[object Object]';
}

/**
 * Deep merge objects
 */
function deepMerge(target, source) {
  if (!isPlainObject(target) || !isPlainObject(source)) {
    return source;
  }
  
  const result = { ...target };
  
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (isPlainObject(source[key])) {
        if (key in target && isPlainObject(target[key])) {
          result[key] = deepMerge(target[key], source[key]);
        } else {
          result[key] = { ...source[key] };
        }
      } else {
        result[key] = source[key];
      }
    }
  }
  
  return result;
}

/**
 * Configuration Manager class
 */
class ConfigManager extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      configDir: path.join(os.homedir(), '.claude', 'config'),
      defaultConfigFile: 'global_config.json',
      envPrefix: 'CLAUDE_',
      schema: null,
      validateOnLoad: true,
      logComponent: 'ConfigManager',
      ...options
    };
    
    this.config = {};
    this.configFiles = new Map();
    this.schema = this.options.schema;
    
    // Create config directory if it doesn't exist
    if (!fs.existsSync(this.options.configDir)) {
      try {
        fs.mkdirSync(this.options.configDir, { recursive: true });
        errorHandler.log('debug', `Created config directory: ${this.options.configDir}`, this.options.logComponent);
      } catch (error) {
        errorHandler.handleError(error, {
          component: this.options.logComponent,
          recovery: `Ensure you have permission to create the directory ${this.options.configDir}`
        });
      }
    }
    
    // Set default configFile path
    this.defaultConfigPath = path.join(this.options.configDir, this.options.defaultConfigFile);
  }
  
  /**
   * Initialize configuration
   * @param {Object} initialConfig - Initial configuration to start with
   */
  initialize(initialConfig = {}) {
    try {
      // Start with empty config
      this.config = {};
      
      // Load the default configuration file if it exists
      if (fs.existsSync(this.defaultConfigPath)) {
        this.loadFile(this.defaultConfigPath);
      } else {
        errorHandler.log('debug', `Default config file not found: ${this.defaultConfigPath}`, this.options.logComponent);
      }
      
      // Merge initialConfig
      this.merge(initialConfig);
      
      // Apply environment variable overrides
      this.applyEnvironmentOverrides();
      
      // Validate configuration if schema is available
      if (this.schema && this.options.validateOnLoad) {
        this.validate();
      }
      
      // Emit initialized event
      this.emit('initialized', this.config);
      
      return this.config;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent,
        recovery: 'Configuration will be set to defaults only'
      });
    }
  }
  
  /**
   * Load configuration from a file
   * @param {string} filePath - Path to the configuration file
   * @param {string} namespace - Optional namespace to load configuration into
   */
  loadFile(filePath, namespace = null) {
    try {
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(this.options.configDir, filePath);
      
      if (!fs.existsSync(fullPath)) {
        throw new Error(`Configuration file not found: ${fullPath}`);
      }
      
      // Read and parse file
      const fileContent = fs.readFileSync(fullPath, 'utf8');
      const fileConfig = JSON.parse(fileContent);
      
      // Track this file
      this.configFiles.set(fullPath, namespace);
      
      // Merge with existing config
      if (namespace) {
        this.set(namespace, fileConfig);
      } else {
        this.merge(fileConfig);
      }
      
      errorHandler.log('debug', `Loaded configuration from ${fullPath}`, this.options.logComponent);
      
      // Emit file loaded event
      this.emit('fileLoaded', { filePath: fullPath, namespace });
      
      return fileConfig;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent,
        recovery: `Ensure ${filePath} contains valid JSON and is readable`
      });
    }
  }
  
  /**
   * Save configuration to a file
   * @param {string} filePath - Path to save the configuration
   * @param {string} namespace - Optional namespace to save
   */
  saveFile(filePath, namespace = null) {
    try {
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(this.options.configDir, filePath);
      
      // Ensure directory exists
      const dirPath = path.dirname(fullPath);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }
      
      // Get configuration to save
      const configToSave = namespace ? this.get(namespace) : this.config;
      
      // Write to file
      fs.writeFileSync(
        fullPath,
        JSON.stringify(configToSave, null, 2),
        'utf8'
      );
      
      // Track this file
      this.configFiles.set(fullPath, namespace);
      
      errorHandler.log('debug', `Saved configuration to ${fullPath}`, this.options.logComponent);
      
      // Emit file saved event
      this.emit('fileSaved', { filePath: fullPath, namespace });
      
      return true;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent,
        recovery: `Ensure you have write permission to ${filePath}`
      });
    }
  }
  
  /**
   * Apply environment variable overrides to configuration
   */
  applyEnvironmentOverrides() {
    try {
      const prefix = this.options.envPrefix;
      
      for (const key in process.env) {
        if (key.startsWith(prefix)) {
          // Get the unprefixed key path
          const configPath = key.substring(prefix.length).toLowerCase().split('__');
          
          // Get the value (attempt to parse as JSON if possible)
          let value = process.env[key];
          
          try {
            // Try to parse as JSON, but only if it starts with [ or {
            if (value.startsWith('{') || value.startsWith('[')) {
              value = JSON.parse(value);
            } else if (value === 'true') {
              value = true;
            } else if (value === 'false') {
              value = false;
            } else if (!isNaN(Number(value)) && value.trim() !== '') {
              value = Number(value);
            }
          } catch (e) {
            // Keep as string if parsing fails
          }
          
          // Set the value in the configuration
          this.set(configPath.join('.'), value);
          
          errorHandler.log('debug', `Applied environment override: ${key}`, this.options.logComponent);
        }
      }
      
      // Emit environment overrides event
      this.emit('environmentOverrides');
      
      return true;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent
      });
    }
  }
  
  /**
   * Set a configuration value
   * @param {string} path - Dot-notation path to the configuration value
   * @param {any} value - Value to set
   */
  set(path, value) {
    try {
      const keys = Array.isArray(path) ? path : path.split('.');
      let current = this.config;
      
      // Traverse the path to the second-to-last key
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        
        // Create objects as needed
        if (!current[key] || typeof current[key] !== 'object') {
          current[key] = {};
        }
        
        current = current[key];
      }
      
      // Set the value at the last key
      const lastKey = keys[keys.length - 1];
      const oldValue = current[lastKey];
      current[lastKey] = value;
      
      // Emit change event if value changed
      if (JSON.stringify(oldValue) !== JSON.stringify(value)) {
        this.emit('changed', { path, oldValue, newValue: value });
      }
      
      return true;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent
      });
    }
  }
  
  /**
   * Get a configuration value
   * @param {string} path - Dot-notation path to the configuration value
   * @param {any} defaultValue - Default value if path is not found
   */
  get(path, defaultValue) {
    try {
      // If no path, return entire config
      if (!path) {
        return this.config;
      }
      
      const keys = Array.isArray(path) ? path : path.split('.');
      let current = this.config;
      
      // Traverse the path
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        
        // Return default if key doesn't exist
        if (!current || current[key] === undefined) {
          return defaultValue;
        }
        
        current = current[key];
      }
      
      return current;
    } catch (error) {
      errorHandler.handleError(error, {
        component: this.options.logComponent
      });
      return defaultValue;
    }
  }
  
  /**
   * Check if a configuration path exists
   * @param {string} path - Dot-notation path to check
   */
  has(path) {
    const value = this.get(path, Symbol('NOT_FOUND'));
    return value !== Symbol('NOT_FOUND');
  }
  
  /**
   * Delete a configuration value
   * @param {string} path - Dot-notation path to delete
   */
  delete(path) {
    try {
      const keys = Array.isArray(path) ? path : path.split('.');
      let current = this.config;
      
      // Traverse the path to the second-to-last key
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        
        // Return false if path doesn't exist
        if (!current || current[key] === undefined) {
          return false;
        }
        
        current = current[key];
      }
      
      // Delete the value at the last key
      const lastKey = keys[keys.length - 1];
      const existed = current && Object.prototype.hasOwnProperty.call(current, lastKey);
      
      if (existed) {
        const oldValue = current[lastKey];
        delete current[lastKey];
        
        // Emit change event
        this.emit('deleted', { path, oldValue });
      }
      
      return existed;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent
      });
    }
  }
  
  /**
   * Merge configuration with existing configuration
   * @param {Object} config - Configuration to merge
   */
  merge(config) {
    try {
      if (!isPlainObject(config)) {
        throw new Error('Configuration must be a plain object');
      }
      
      // Merge with existing config
      this.config = deepMerge(this.config, config);
      
      // Emit merged event
      this.emit('merged', config);
      
      return this.config;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent
      });
    }
  }
  
  /**
   * Reset configuration to empty state
   */
  reset() {
    this.config = {};
    this.configFiles.clear();
    
    // Emit reset event
    this.emit('reset');
    
    return true;
  }
  
  /**
   * Reload configuration from all tracked files
   */
  reload() {
    try {
      // Reset configuration
      this.config = {};
      
      // Load all tracked files
      for (const [filePath, namespace] of this.configFiles) {
        try {
          this.loadFile(filePath, namespace);
        } catch (error) {
          errorHandler.log('warn', `Failed to reload ${filePath}: ${error.message}`, this.options.logComponent);
        }
      }
      
      // Apply environment variable overrides
      this.applyEnvironmentOverrides();
      
      // Validate configuration if schema is available
      if (this.schema && this.options.validateOnLoad) {
        this.validate();
      }
      
      // Emit reloaded event
      this.emit('reloaded', this.config);
      
      return this.config;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent,
        recovery: 'Configuration may be incomplete'
      });
    }
  }
  
  /**
   * Validate configuration against schema
   */
  validate() {
    if (!this.schema) {
      return true;
    }
    
    try {
      // Implement validation logic here based on this.schema
      // For a simple implementation, we'll just check for required fields
      const validateObject = (obj, schema, path = '') => {
        if (!schema.properties) {
          return true;
        }
        
        // Check required fields
        if (schema.required && Array.isArray(schema.required)) {
          for (const requiredField of schema.required) {
            if (obj[requiredField] === undefined) {
              throw new Error(`Required field missing: ${path ? path + '.' : ''}${requiredField}`);
            }
          }
        }
        
        // Check properties
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            const value = obj[key];
            const propertySchema = schema.properties[key];
            
            if (!propertySchema) {
              if (schema.additionalProperties === false) {
                throw new Error(`Unknown property: ${path ? path + '.' : ''}${key}`);
              }
              continue;
            }
            
            // Check type
            if (propertySchema.type) {
              const type = Array.isArray(value) ? 'array' : typeof value;
              
              if (type === 'object' && value !== null && propertySchema.type === 'object' && propertySchema.properties) {
                // Recursively validate nested objects
                validateObject(value, propertySchema, path ? `${path}.${key}` : key);
              } else if (propertySchema.type !== type) {
                throw new Error(`Invalid type for ${path ? path + '.' : ''}${key}: expected ${propertySchema.type}, got ${type}`);
              }
            }
            
            // Check enum
            if (propertySchema.enum && !propertySchema.enum.includes(value)) {
              throw new Error(`Invalid value for ${path ? path + '.' : ''}${key}: must be one of [${propertySchema.enum.join(', ')}]`);
            }
          }
        }
        
        return true;
      };
      
      validateObject(this.config, this.schema);
      
      // Emit validated event
      this.emit('validated', this.config);
      
      return true;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent,
        type: 'validation',
        recovery: 'Fix the validation issues and reload the configuration'
      });
    }
  }
  
  /**
   * Get metadata about configuration
   */
  getMetadata() {
    return {
      configDir: this.options.configDir,
      defaultConfigFile: this.options.defaultConfigFile,
      trackedFiles: Array.from(this.configFiles.keys()),
      schemaAvailable: !!this.schema,
      lastModified: new Date().toISOString()
    };
  }
  
  /**
   * Create or overwrite default configuration
   * @param {Object} defaultConfig - Default configuration to save
   */
  createDefaultConfig(defaultConfig = {}) {
    try {
      // Set default configuration
      this.reset();
      this.merge(defaultConfig);
      
      // Save to default config file
      this.saveFile(this.defaultConfigPath);
      
      return true;
    } catch (error) {
      return errorHandler.handleError(error, {
        component: this.options.logComponent,
        recovery: 'Ensure you have write permission to the config directory'
      });
    }
  }
  
  /**
   * Set schema for validation
   * @param {Object} schema - JSON Schema for validation
   */
  setSchema(schema) {
    this.schema = schema;
    
    // Validate against new schema
    if (this.options.validateOnLoad) {
      this.validate();
    }
    
    return true;
  }
}

// Create singleton instance
const defaultConfigManager = new ConfigManager();

// Export class and default instance
module.exports = {
  ConfigManager,
  defaultConfigManager
};

// If this is the main module, initialize with default settings
if (require.main === module) {
  defaultConfigManager.initialize();
  console.log('Configuration manager initialized');
}