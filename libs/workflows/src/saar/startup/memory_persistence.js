/**
 * Memory Persistence Module for DeepThink
 * 
 * This module provides persistent storage and categorization for
 * thoughts generated by the DeepThink system, enabling knowledge
 * reuse and pattern recognition across multiple thinking sessions.
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Configuration
const CONFIG_DIR = process.env.HOME + '/.claude';
const MEMORY_DIR = path.join(CONFIG_DIR, 'memory');
const CATEGORIES_FILE = path.join(MEMORY_DIR, 'categories.json');
const MEMORY_INDEX = path.join(MEMORY_DIR, 'thought_index.json');
const MAX_MEMORY_SIZE = 10000; // Maximum number of thoughts to store

// Ensure memory directory exists
if (!fs.existsSync(MEMORY_DIR)) {
  fs.mkdirSync(MEMORY_DIR, { recursive: true });
}

// Memory categories
let categories = {
  // Default categories
  "problem_analysis": {
    description: "Analysis of problem statements and requirements",
    tags: ["analysis", "problem", "requirements"]
  },
  "solution_design": {
    description: "Design and architecture of solutions",
    tags: ["design", "architecture", "solution"]
  },
  "implementation": {
    description: "Implementation details and code",
    tags: ["implementation", "code", "development"]
  },
  "testing": {
    description: "Testing strategies and approaches",
    tags: ["testing", "validation", "verification"]
  },
  "learning": {
    description: "Learning and insights from experiences",
    tags: ["learning", "insight", "knowledge"]
  }
};

// Memory index
let memoryIndex = {
  "thoughts": [],
  "last_updated": new Date().toISOString(),
  "total_count": 0
};

// Load existing categories
function loadCategories() {
  if (fs.existsSync(CATEGORIES_FILE)) {
    try {
      categories = JSON.parse(fs.readFileSync(CATEGORIES_FILE, 'utf8'));
      console.log(`Loaded ${Object.keys(categories).length} memory categories`);
    } catch (err) {
      console.error(`Error loading categories: ${err.message}`);
    }
  } else {
    // Save default categories
    saveCategories();
  }
}

// Save categories
function saveCategories() {
  try {
    fs.writeFileSync(CATEGORIES_FILE, JSON.stringify(categories, null, 2));
    console.log(`Saved ${Object.keys(categories).length} memory categories`);
  } catch (err) {
    console.error(`Error saving categories: ${err.message}`);
  }
}

// Load memory index
function loadMemoryIndex() {
  if (fs.existsSync(MEMORY_INDEX)) {
    try {
      memoryIndex = JSON.parse(fs.readFileSync(MEMORY_INDEX, 'utf8'));
      console.log(`Loaded memory index with ${memoryIndex.thoughts.length} thoughts`);
    } catch (err) {
      console.error(`Error loading memory index: ${err.message}`);
    }
  } else {
    // Save default index
    saveMemoryIndex();
  }
}

// Save memory index
function saveMemoryIndex() {
  try {
    memoryIndex.last_updated = new Date().toISOString();
    memoryIndex.total_count = memoryIndex.thoughts.length;
    
    fs.writeFileSync(MEMORY_INDEX, JSON.stringify(memoryIndex, null, 2));
    console.log(`Saved memory index with ${memoryIndex.thoughts.length} thoughts`);
  } catch (err) {
    console.error(`Error saving memory index: ${err.message}`);
  }
}

// Create a unique ID for a thought
function createThoughtId(content) {
  return crypto.createHash('md5').update(content).digest('hex');
}

// Store a thought in memory
function storeThought(thought, category, source) {
  if (!thought || !thought.content) {
    console.error('Invalid thought object');
    return null;
  }
  
  // Generate a unique ID
  const thoughtId = thought.id || createThoughtId(thought.content);
  
  // Check if thought already exists
  const existingIndex = memoryIndex.thoughts.findIndex(t => t.id === thoughtId);
  
  if (existingIndex >= 0) {
    // Update existing thought
    memoryIndex.thoughts[existingIndex].access_count += 1;
    memoryIndex.thoughts[existingIndex].last_accessed = new Date().toISOString();
    
    if (category && !memoryIndex.thoughts[existingIndex].categories.includes(category)) {
      memoryIndex.thoughts[existingIndex].categories.push(category);
    }
    
    console.log(`Updated existing thought: ${thoughtId}`);
    
    // Save the thought file with updated metadata
    saveThoughtFile(memoryIndex.thoughts[existingIndex]);
    
    // Return the existing thought
    return memoryIndex.thoughts[existingIndex];
  }
  
  // Prepare thought metadata
  const thoughtMetadata = {
    id: thoughtId,
    content: thought.content,
    created_at: new Date().toISOString(),
    last_accessed: new Date().toISOString(),
    access_count: 1,
    categories: category ? [category] : [],
    source: source || 'deepthink',
    related_thoughts: []
  };
  
  // Save thought to file
  saveThoughtFile(thoughtMetadata);
  
  // Add to index
  memoryIndex.thoughts.push({
    id: thoughtId,
    summary: thought.content.substring(0, 100) + (thought.content.length > 100 ? '...' : ''),
    categories: thoughtMetadata.categories,
    created_at: thoughtMetadata.created_at,
    last_accessed: thoughtMetadata.last_accessed,
    access_count: thoughtMetadata.access_count,
    source: thoughtMetadata.source
  });
  
  // Ensure we don't exceed the maximum memory size
  if (memoryIndex.thoughts.length > MAX_MEMORY_SIZE) {
    // Remove the least accessed thought
    const leastAccessed = [...memoryIndex.thoughts]
      .sort((a, b) => a.access_count - b.access_count)[0];
    
    memoryIndex.thoughts = memoryIndex.thoughts.filter(t => t.id !== leastAccessed.id);
    
    // Remove the thought file
    const thoughtFile = path.join(MEMORY_DIR, `${leastAccessed.id}.json`);
    if (fs.existsSync(thoughtFile)) {
      fs.unlinkSync(thoughtFile);
    }
    
    console.log(`Removed least accessed thought: ${leastAccessed.id}`);
  }
  
  // Save updated index
  saveMemoryIndex();
  
  console.log(`Stored new thought: ${thoughtId}`);
  
  return thoughtMetadata;
}

// Save thought to file
function saveThoughtFile(thought) {
  const thoughtFile = path.join(MEMORY_DIR, `${thought.id}.json`);
  
  try {
    fs.writeFileSync(thoughtFile, JSON.stringify(thought, null, 2));
  } catch (err) {
    console.error(`Error saving thought file: ${err.message}`);
  }
}

// Retrieve a thought by ID
function retrieveThought(thoughtId) {
  const thoughtFile = path.join(MEMORY_DIR, `${thoughtId}.json`);
  
  if (!fs.existsSync(thoughtFile)) {
    console.error(`Thought file not found: ${thoughtId}`);
    return null;
  }
  
  try {
    const thought = JSON.parse(fs.readFileSync(thoughtFile, 'utf8'));
    
    // Update access metadata
    const index = memoryIndex.thoughts.findIndex(t => t.id === thoughtId);
    if (index >= 0) {
      memoryIndex.thoughts[index].access_count += 1;
      memoryIndex.thoughts[index].last_accessed = new Date().toISOString();
    }
    
    // Save updated index
    saveMemoryIndex();
    
    return thought;
  } catch (err) {
    console.error(`Error retrieving thought: ${err.message}`);
    return null;
  }
}

// Search thoughts by content
function searchThoughts(query, category = null, limit = 10) {
  let results = [];
  
  // Filter by category if specified
  let candidates = category
    ? memoryIndex.thoughts.filter(t => t.categories.includes(category))
    : memoryIndex.thoughts;
  
  // Simple text search
  for (const thought of candidates) {
    const thoughtFile = path.join(MEMORY_DIR, `${thought.id}.json`);
    
    if (fs.existsSync(thoughtFile)) {
      try {
        const fullThought = JSON.parse(fs.readFileSync(thoughtFile, 'utf8'));
        
        if (fullThought.content.toLowerCase().includes(query.toLowerCase())) {
          results.push(fullThought);
        }
        
        // Limit results
        if (results.length >= limit) {
          break;
        }
      } catch (err) {
        console.error(`Error reading thought file: ${err.message}`);
      }
    }
  }
  
  return results;
}

// Categorize a thought based on its content
function categorizeThought(content) {
  // This is a simple keyword-based categorization
  // In a real implementation, this would use more sophisticated NLP
  
  const categoryScores = {};
  
  // Calculate score for each category based on tag matches
  for (const [categoryName, category] of Object.entries(categories)) {
    categoryScores[categoryName] = 0;
    
    for (const tag of category.tags) {
      // Count occurrences of tag in content
      const regex = new RegExp(`\\b${tag}\\b`, 'gi');
      const matches = content.match(regex) || [];
      categoryScores[categoryName] += matches.length;
    }
  }
  
  // Find category with highest score
  let bestCategory = null;
  let bestScore = 0;
  
  for (const [categoryName, score] of Object.entries(categoryScores)) {
    if (score > bestScore) {
      bestScore = score;
      bestCategory = categoryName;
    }
  }
  
  // If no good match, use "learning" as default
  return bestScore > 0 ? bestCategory : "learning";
}

// Create a relationship between thoughts
function relateThoughts(sourceId, targetId, relationship = "related") {
  const sourceFile = path.join(MEMORY_DIR, `${sourceId}.json`);
  const targetFile = path.join(MEMORY_DIR, `${targetId}.json`);
  
  if (!fs.existsSync(sourceFile) || !fs.existsSync(targetFile)) {
    console.error('Source or target thought not found');
    return false;
  }
  
  try {
    // Update source thought
    const sourceThought = JSON.parse(fs.readFileSync(sourceFile, 'utf8'));
    
    if (!sourceThought.related_thoughts) {
      sourceThought.related_thoughts = [];
    }
    
    if (!sourceThought.related_thoughts.some(r => r.id === targetId)) {
      sourceThought.related_thoughts.push({
        id: targetId,
        relationship,
        created_at: new Date().toISOString()
      });
      
      fs.writeFileSync(sourceFile, JSON.stringify(sourceThought, null, 2));
    }
    
    // Update target thought
    const targetThought = JSON.parse(fs.readFileSync(targetFile, 'utf8'));
    
    if (!targetThought.related_thoughts) {
      targetThought.related_thoughts = [];
    }
    
    if (!targetThought.related_thoughts.some(r => r.id === sourceId)) {
      targetThought.related_thoughts.push({
        id: sourceId,
        relationship: getReciprocal(relationship),
        created_at: new Date().toISOString()
      });
      
      fs.writeFileSync(targetFile, JSON.stringify(targetThought, null, 2));
    }
    
    return true;
  } catch (err) {
    console.error(`Error relating thoughts: ${err.message}`);
    return false;
  }
}

// Get reciprocal relationship
function getReciprocal(relationship) {
  const reciprocals = {
    "builds_on": "foundation_for",
    "contradicts": "contradicted_by",
    "supports": "supported_by",
    "refines": "refined_by",
    "extends": "extended_by",
    "related": "related"
  };
  
  return reciprocals[relationship] || "related";
}

// Get thought statistics
function getMemoryStats() {
  return {
    total_thoughts: memoryIndex.thoughts.length,
    categories: Object.keys(categories).map(name => ({
      name,
      description: categories[name].description,
      count: memoryIndex.thoughts.filter(t => t.categories.includes(name)).length
    })),
    last_updated: memoryIndex.last_updated,
    oldest_thought: memoryIndex.thoughts.length > 0 
      ? memoryIndex.thoughts.reduce((oldest, t) => 
          oldest.created_at < t.created_at ? oldest : t
        ).created_at
      : null,
    newest_thought: memoryIndex.thoughts.length > 0
      ? memoryIndex.thoughts.reduce((newest, t) => 
          newest.created_at > t.created_at ? newest : t
        ).created_at
      : null
  };
}

// Initialize the module
function initialize() {
  loadCategories();
  loadMemoryIndex();
  
  return {
    storeThought,
    retrieveThought,
    searchThoughts,
    categorizeThought,
    relateThoughts,
    getMemoryStats
  };
}

// Export the memory module
module.exports = initialize();

// If this script is executed directly, show stats
if (require.main === module) {
  const memory = initialize();
  console.log(JSON.stringify(memory.getMemoryStats(), null, 2));
}