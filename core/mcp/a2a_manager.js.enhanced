/**
 * Agent-to-Agent (A2A) Manager
 * 
 * This module provides a comprehensive system for managing communication
 * between specialized agents in the Claude Neural Framework.
 * 
 * Features:
 * - Auto-discovery of available agents
 * - Configuration validation
 * - Message routing between agents
 * - Lifecycle management for agents
 * - Event-based communication system
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { EventEmitter } = require('events');

// Configuration
const DEFAULT_CONFIG = {
  managerEnabled: true,
  port: 3210,
  registryPath: path.join(os.homedir(), '.claude', 'agents', 'agent_registry.json'),
  logLevel: 'info',
  autoStartAgents: [],
  messageBroker: {
    type: 'local',
    queueSize: 100,
    retentionPeriod: 86400
  }
};

class A2AManager {
  constructor(options = {}) {
    this.options = {
      configPath: path.join(os.homedir(), '.claude', 'agents', 'a2a_config.json'),
      workspacePath: process.cwd(),
      autoDiscover: true,
      ...options
    };
    
    // Initialize state
    this.config = DEFAULT_CONFIG;
    this.agents = new Map();
    this.running = false;
    this.eventBus = new EventEmitter();
    
    // Load configuration
    this.loadConfig();
    
    // Set up event listeners
    this.setupEventListeners();
  }
  
  /**
   * Load configuration from file
   */
  loadConfig() {
    try {
      if (fs.existsSync(this.options.configPath)) {
        const config = JSON.parse(fs.readFileSync(this.options.configPath, 'utf8'));
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.log('debug', `Configuration loaded from ${this.options.configPath}`);
      } else {
        this.log('warn', `Configuration file not found at ${this.options.configPath}, using defaults`);
        // Save default configuration if file doesn't exist
        this.saveConfig();
      }
    } catch (error) {
      this.log('error', `Error loading configuration: ${error.message}`);
      this.config = DEFAULT_CONFIG;
    }
  }
  
  /**
   * Save configuration to file
   */
  saveConfig() {
    try {
      // Ensure directory exists
      const configDir = path.dirname(this.options.configPath);
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
      }
      
      // Update timestamp
      this.config.lastUpdated = new Date().toISOString();
      
      // Write to file
      fs.writeFileSync(
        this.options.configPath,
        JSON.stringify(this.config, null, 2),
        'utf8'
      );
      
      this.log('debug', `Configuration saved to ${this.options.configPath}`);
    } catch (error) {
      this.log('error', `Error saving configuration: ${error.message}`);
    }
  }
  
  /**
   * Set up event listeners
   */
  setupEventListeners() {
    this.eventBus.on('agent:registered', (agent) => {
      this.log('info', `Agent registered: ${agent.id}`);
    });
    
    this.eventBus.on('agent:unregistered', (agentId) => {
      this.log('info', `Agent unregistered: ${agentId}`);
    });
    
    this.eventBus.on('message:sent', (message) => {
      this.log('debug', `Message sent from ${message.from} to ${message.to}`);
    });
    
    this.eventBus.on('message:delivered', (message) => {
      this.log('debug', `Message delivered to ${message.to}`);
    });
    
    this.eventBus.on('message:failed', (message, error) => {
      this.log('error', `Message delivery failed: ${error.message}`);
    });
    
    this.eventBus.on('error', (error) => {
      this.log('error', `A2A Manager error: ${error.message}`);
    });
  }
  
  /**
   * Log message with specified level
   */
  log(level, message) {
    const levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3
    };
    
    // Only log if level is at or above configured level
    if (levels[level] <= levels[this.config.logLevel]) {
      const timestamp = new Date().toISOString();
      const formattedMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
      
      // Output to console
      switch (level) {
        case 'error':
          console.error(formattedMessage);
          break;
        case 'warn':
          console.warn(formattedMessage);
          break;
        case 'info':
          console.info(formattedMessage);
          break;
        case 'debug':
          console.debug(formattedMessage);
          break;
      }
      
      // Emit log event for potential external handling
      this.eventBus.emit('log', {
        timestamp,
        level,
        message
      });
    }
  }
  
  /**
   * Auto-discover available agents
   */
  async discoverAgents() {
    try {
      this.log('info', 'Starting agent discovery');
      const discoveredAgents = [];
      
      // Check if registry exists
      if (fs.existsSync(this.config.registryPath)) {
        // Load from registry
        const registry = JSON.parse(fs.readFileSync(this.config.registryPath, 'utf8'));
        if (registry.agents && Array.isArray(registry.agents)) {
          discoveredAgents.push(...registry.agents);
          this.log('info', `Found ${registry.agents.length} agents in registry`);
        }
      } else {
        this.log('warn', `Agent registry not found at ${this.config.registryPath}`);
      }
      
      // Find agents in workspace
      if (this.options.autoDiscover) {
        this.log('info', 'Scanning workspace for agent definitions');
        
        // Check agents/commands directory
        const commandsDir = path.join(this.options.workspacePath, 'agents', 'commands');
        if (fs.existsSync(commandsDir)) {
          const commandFiles = fs.readdirSync(commandsDir).filter(file => file.endsWith('.md'));
          
          // Create configs for discovered agents
          for (const file of commandFiles) {
            const agentType = path.basename(file, '.md');
            const agentId = `${agentType.replace(/-/g, '_')}_agent`;
            
            // Check if already in discovered agents
            if (!discoveredAgents.some(agent => agent.agentId === agentId)) {
              // Read file to extract agent name and capabilities
              const content = fs.readFileSync(path.join(commandsDir, file), 'utf8');
              
              // Extract name from first line (# Agent Name)
              const nameMatch = content.match(/^#\s+(.+)$/m);
              const displayName = nameMatch ? nameMatch[1].trim() : agentType.replace(/-/g, ' ');
              
              // Add to discovered agents
              discoveredAgents.push({
                agentId: agentId,
                agentType: agentType,
                displayName: displayName,
                commandFile: path.join(commandsDir, file)
              });
              
              this.log('debug', `Discovered agent: ${agentId} (${displayName})`);
            }
          }
          
          this.log('info', `Discovered ${commandFiles.length} potential agents in workspace`);
        } else {
          this.log('warn', 'Agents commands directory not found in workspace');
        }
      }
      
      // Update registry if new agents were discovered
      if (discoveredAgents.length > 0) {
        // Create registry directory if it doesn't exist
        const registryDir = path.dirname(this.config.registryPath);
        if (!fs.existsSync(registryDir)) {
          fs.mkdirSync(registryDir, { recursive: true });
        }
        
        // Get existing registry or create new one
        let registry = { agents: [], lastUpdated: new Date().toISOString() };
        if (fs.existsSync(this.config.registryPath)) {
          try {
            registry = JSON.parse(fs.readFileSync(this.config.registryPath, 'utf8'));
          } catch (error) {
            this.log('error', `Error parsing registry: ${error.message}`);
          }
        }
        
        // Merge discovered agents with existing registry
        const existingAgentIds = new Set(registry.agents.map(agent => agent.agentId));
        for (const agent of discoveredAgents) {
          if (!existingAgentIds.has(agent.agentId)) {
            registry.agents.push(agent);
            existingAgentIds.add(agent.agentId);
          }
        }
        
        // Update registry
        registry.lastUpdated = new Date().toISOString();
        fs.writeFileSync(this.config.registryPath, JSON.stringify(registry, null, 2), 'utf8');
        
        this.log('info', `Updated agent registry with ${registry.agents.length} agents`);
      }
      
      return discoveredAgents;
    } catch (error) {
      this.log('error', `Error discovering agents: ${error.message}`);
      return [];
    }
  }
  
  /**
   * Validate agent configuration
   */
  validateAgentConfig(config) {
    // Validate required fields
    const requiredFields = ['agentId', 'agentType'];
    for (const field of requiredFields) {
      if (!config[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }
    
    // Validate command file if specified
    if (config.commandFile && !fs.existsSync(config.commandFile)) {
      throw new Error(`Command file not found: ${config.commandFile}`);
    }
    
    return true;
  }
  
  /**
   * Register an agent with the manager
   */
  registerAgent(config) {
    try {
      // Validate agent configuration
      this.validateAgentConfig(config);
      
      // Create standardized agent object
      const agent = {
        id: config.agentId,
        type: config.agentType,
        displayName: config.displayName || config.agentType.replace(/-/g, ' '),
        commandFile: config.commandFile,
        status: 'registered',
        capabilities: config.capabilities || [config.agentType],
        preferences: config.preferences || {
          autoStart: false,
          notificationLevel: 'important'
        },
        created: config.created || new Date().toISOString(),
        lastActive: config.lastActive || new Date().toISOString()
      };
      
      // Add to agents map
      this.agents.set(agent.id, agent);
      
      // Emit event
      this.eventBus.emit('agent:registered', agent);
      
      return agent;
    } catch (error) {
      this.log('error', `Error registering agent: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Unregister an agent
   */
  unregisterAgent(agentId) {
    if (this.agents.has(agentId)) {
      this.agents.delete(agentId);
      this.eventBus.emit('agent:unregistered', agentId);
      return true;
    }
    
    return false;
  }
  
  /**
   * Start the A2A Manager
   */
  async start() {
    if (this.running) {
      this.log('warn', 'A2A Manager is already running');
      return;
    }
    
    try {
      this.log('info', 'Starting A2A Manager');
      
      // Discover agents
      const discoveredAgents = await this.discoverAgents();
      
      // Register all discovered agents
      for (const agentConfig of discoveredAgents) {
        try {
          this.registerAgent(agentConfig);
        } catch (error) {
          this.log('error', `Failed to register agent ${agentConfig.agentId}: ${error.message}`);
        }
      }
      
      this.log('info', `Registered ${this.agents.size} agents`);
      
      // Auto-start configured agents
      if (this.config.autoStartAgents && this.config.autoStartAgents.length > 0) {
        this.log('info', `Auto-starting ${this.config.autoStartAgents.length} agents`);
        
        for (const agentId of this.config.autoStartAgents) {
          if (this.agents.has(agentId)) {
            try {
              await this.startAgent(agentId);
            } catch (error) {
              this.log('error', `Failed to auto-start agent ${agentId}: ${error.message}`);
            }
          } else {
            this.log('warn', `Cannot auto-start agent ${agentId}: Agent not registered`);
          }
        }
      }
      
      this.running = true;
      this.log('info', 'A2A Manager started successfully');
    } catch (error) {
      this.log('error', `Failed to start A2A Manager: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Stop the A2A Manager
   */
  async stop() {
    if (!this.running) {
      this.log('warn', 'A2A Manager is not running');
      return;
    }
    
    try {
      this.log('info', 'Stopping A2A Manager');
      
      // Stop all running agents
      const runningAgents = [...this.agents.values()].filter(agent => agent.status === 'running');
      
      for (const agent of runningAgents) {
        try {
          await this.stopAgent(agent.id);
        } catch (error) {
          this.log('error', `Failed to stop agent ${agent.id}: ${error.message}`);
        }
      }
      
      this.running = false;
      this.log('info', 'A2A Manager stopped successfully');
    } catch (error) {
      this.log('error', `Failed to stop A2A Manager: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Start an agent
   */
  async startAgent(agentId) {
    if (!this.agents.has(agentId)) {
      throw new Error(`Agent not found: ${agentId}`);
    }
    
    const agent = this.agents.get(agentId);
    
    if (agent.status === 'running') {
      this.log('warn', `Agent ${agentId} is already running`);
      return agent;
    }
    
    try {
      this.log('info', `Starting agent: ${agentId}`);
      
      // Update agent status
      agent.status = 'running';
      agent.lastActive = new Date().toISOString();
      
      // Emit event
      this.eventBus.emit('agent:started', agent);
      
      return agent;
    } catch (error) {
      this.log('error', `Failed to start agent ${agentId}: ${error.message}`);
      agent.status = 'error';
      throw error;
    }
  }
  
  /**
   * Stop an agent
   */
  async stopAgent(agentId) {
    if (!this.agents.has(agentId)) {
      throw new Error(`Agent not found: ${agentId}`);
    }
    
    const agent = this.agents.get(agentId);
    
    if (agent.status !== 'running') {
      this.log('warn', `Agent ${agentId} is not running`);
      return agent;
    }
    
    try {
      this.log('info', `Stopping agent: ${agentId}`);
      
      // Update agent status
      agent.status = 'stopped';
      agent.lastActive = new Date().toISOString();
      
      // Emit event
      this.eventBus.emit('agent:stopped', agent);
      
      return agent;
    } catch (error) {
      this.log('error', `Failed to stop agent ${agentId}: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Send a message from one agent to another
   */
  async sendMessage(fromAgentId, toAgentId, content, options = {}) {
    try {
      // Validate agents
      if (!this.agents.has(fromAgentId)) {
        throw new Error(`Sender agent not found: ${fromAgentId}`);
      }
      
      if (!this.agents.has(toAgentId)) {
        throw new Error(`Recipient agent not found: ${toAgentId}`);
      }
      
      // Create message object
      const message = {
        id: options.id || `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        from: fromAgentId,
        to: toAgentId,
        content,
        timestamp: new Date().toISOString(),
        metadata: options.metadata || {},
        priority: options.priority || 'normal'
      };
      
      // Emit message sent event
      this.eventBus.emit('message:sent', message);
      
      // Check if recipient agent is running
      const toAgent = this.agents.get(toAgentId);
      if (toAgent.status !== 'running') {
        throw new Error(`Recipient agent ${toAgentId} is not running`);
      }
      
      // Process message
      try {
        // Update recipient agent's last active timestamp
        toAgent.lastActive = new Date().toISOString();
        
        // Emit message delivered event
        this.eventBus.emit('message:delivered', message);
        
        return {
          success: true,
          messageId: message.id,
          timestamp: message.timestamp
        };
      } catch (error) {
        // Emit message failed event
        this.eventBus.emit('message:failed', message, error);
        throw error;
      }
    } catch (error) {
      this.log('error', `Error sending message: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * List all registered agents
   */
  listAgents() {
    return [...this.agents.values()].map(agent => ({
      id: agent.id,
      type: agent.type,
      displayName: agent.displayName,
      status: agent.status,
      capabilities: agent.capabilities,
      lastActive: agent.lastActive
    }));
  }
  
  /**
   * Get detailed information about an agent
   */
  getAgentDetails(agentId) {
    if (!this.agents.has(agentId)) {
      throw new Error(`Agent not found: ${agentId}`);
    }
    
    return this.agents.get(agentId);
  }
  
  /**
   * Update agent configuration
   */
  updateAgentConfig(agentId, config) {
    if (!this.agents.has(agentId)) {
      throw new Error(`Agent not found: ${agentId}`);
    }
    
    const agent = this.agents.get(agentId);
    
    // Update agent properties
    Object.assign(agent, {
      ...config,
      id: agentId, // Don't allow ID to be changed
      lastModified: new Date().toISOString()
    });
    
    // Emit event
    this.eventBus.emit('agent:updated', agent);
    
    return agent;
  }
  
  /**
   * Find agents by capability
   */
  findAgentsByCapability(capability) {
    return [...this.agents.values()].filter(agent => 
      agent.capabilities && agent.capabilities.includes(capability)
    );
  }
  
  /**
   * Register event handlers
   */
  on(event, handler) {
    this.eventBus.on(event, handler);
  }
  
  /**
   * Remove event handlers
   */
  off(event, handler) {
    this.eventBus.off(event, handler);
  }
}

// Command-line interface
if (require.main === module) {
  const args = process.argv.slice(2);
  const manager = new A2AManager();
  
  const printAgentList = () => {
    const agents = manager.listAgents();
    console.log('\nRegistered Agents:');
    console.log('-----------------');
    
    if (agents.length === 0) {
      console.log('No agents registered');
    } else {
      agents.forEach(agent => {
        console.log(`${agent.displayName} (${agent.id})`);
        console.log(`  Type: ${agent.type}`);
        console.log(`  Status: ${agent.status}`);
        console.log(`  Capabilities: ${agent.capabilities.join(', ')}`);
        console.log(`  Last Active: ${agent.lastActive}`);
        console.log();
      });
    }
  };
  
  const handleCommand = async (command, subCommand) => {
    switch (command) {
      case 'start':
        await manager.start();
        console.log('\nA2A Manager started successfully');
        printAgentList();
        break;
        
      case 'stop':
        await manager.stop();
        console.log('\nA2A Manager stopped successfully');
        break;
        
      case 'list':
        printAgentList();
        break;
        
      case 'register':
        if (!subCommand) {
          console.error('Agent type is required for registration');
          process.exit(1);
        }
        
        try {
          const agentType = subCommand;
          const agentId = `${agentType.replace(/-/g, '_')}_agent`;
          const displayName = agentType.replace(/-/g, ' ')
            .replace(/\b\w/g, c => c.toUpperCase());
          
          const agent = manager.registerAgent({
            agentId,
            agentType,
            displayName,
            capabilities: [agentType]
          });
          
          console.log(`\nAgent registered: ${agent.displayName} (${agent.id})`);
        } catch (error) {
          console.error(`Error registering agent: ${error.message}`);
          process.exit(1);
        }
        break;
        
      case 'setup':
        try {
          await manager.discoverAgents();
          await manager.start();
          console.log('\nAgent setup completed successfully');
          printAgentList();
        } catch (error) {
          console.error(`Error during setup: ${error.message}`);
          process.exit(1);
        }
        break;
        
      case 'send':
        if (args.length < 4) {
          console.error('Usage: a2a_manager.js send [from-agent] [to-agent] [message]');
          process.exit(1);
        }
        
        try {
          const fromAgentId = args[1];
          const toAgentId = args[2];
          const message = args.slice(3).join(' ');
          
          await manager.start(); // Make sure manager is running
          
          // Start source and target agents if needed
          await manager.startAgent(fromAgentId);
          await manager.startAgent(toAgentId);
          
          const result = await manager.sendMessage(fromAgentId, toAgentId, message);
          console.log(`\nMessage sent successfully (ID: ${result.messageId})`);
        } catch (error) {
          console.error(`Error sending message: ${error.message}`);
          process.exit(1);
        }
        break;
        
      case '--help':
      case 'help':
      default:
        console.log('\nA2A Manager - Claude Neural Framework');
        console.log('-----------------------------------');
        console.log('\nCommands:');
        console.log('  start                Start the A2A Manager');
        console.log('  stop                 Stop the A2A Manager');
        console.log('  list                 List all registered agents');
        console.log('  register [type]      Register an agent of the specified type');
        console.log('  setup                Auto-discover and setup all available agents');
        console.log('  send [from] [to] [message]  Send a message from one agent to another');
        console.log('  help                 Show this help message');
        console.log();
        break;
    }
  };
  
  // Execute command
  if (args.length > 0) {
    handleCommand(args[0], args[1]);
  } else {
    handleCommand('help');
  }
}

module.exports = A2AManager;