#!/bin/bash

# SAAR.sh - Setup, Activate, Apply, Run
# Unified Agentic OS for Claude Neural Framework
# Version: 2.1.0

# Strict error handling
set -e
set -o pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Configuration
CONFIG_DIR="$HOME/.claude"
WORKSPACE_DIR="$(pwd)"
STORAGE_DIR="$CONFIG_DIR/storage"
MEMORY_FILE="$STORAGE_DIR/agentic-os-memory.json"
THEME_FILE="$CONFIG_DIR/theme.json"
DEFAULT_USER="claudeuser"
LOG_FILE="$CONFIG_DIR/saar.log"
ERROR_LOG_FILE="$CONFIG_DIR/saar.error.log"
TEMP_DIR="$CONFIG_DIR/tmp"

# Setup Configuration
SETUP_CONFIG_FILE="$CONFIG_DIR/setup_config.json"
DEFAULT_SETUP_CONFIG='{
  "version": "2.1.0",
  "dependencies": {
    "required": ["node", "npm", "python3", "git"],
    "optional": ["docker", "docker-compose", "pip", "gcc", "make"]
  },
  "node": {
    "min_version": "16.0.0",
    "recommended_version": "20.0.0",
    "packages": ["@anthropic/sdk", "@modelcontextprotocol/client", "chalk", "inquirer"]
  },
  "python": {
    "min_version": "3.8.0",
    "recommended_version": "3.10.0",
    "packages": ["anthropic", "lancedb", "voyage", "sentence-transformers", "numpy", "pandas"]
  },
  "advanced_tools": {
    "recursive_debugging": {
      "enabled": true,
      "repository": "https://github.com/claude-framework/recursive-debugging.git",
      "branch": "main",
      "path": "tools/recursive-debugging"
    },
    "neural_framework": {
      "enabled": true,
      "repository": "https://github.com/claude-framework/neural-framework.git",
      "branch": "main",
      "path": "tools/neural-framework"
    },
    "a2a_framework": {
      "enabled": true,
      "agents_path": "agents/commands",
      "config_path": "core/mcp/a2a_config.json"
    }
  }
}'

#
# HELPER FUNCTIONS
#

# Banner function
show_banner() {
  echo -e "${PURPLE}${BOLD}"
  echo "  █████╗  ██████╗ ███████╗███╗   ██╗████████╗██╗ ██████╗     ██████╗ ███████╗"
  echo " ██╔══██╗██╔════╝ ██╔════╝████╗  ██║╚══██╔══╝██║██╔════╝    ██╔═══██╗██╔════╝"
  echo " ███████║██║  ███╗█████╗  ██╔██╗ ██║   ██║   ██║██║         ██║   ██║███████╗"
  echo " ██╔══██║██║   ██║██╔══╝  ██║╚██╗██║   ██║   ██║██║         ██║   ██║╚════██║"
  echo " ██║  ██║╚██████╔╝███████╗██║ ╚████║   ██║   ██║╚██████╗    ╚██████╔╝███████║"
  echo " ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝ ╚═════╝     ╚═════╝ ╚══════╝"                                                           
  echo -e "${NC}"
  echo -e "${CYAN}${BOLD}Claude Neural Framework - ONE Agentic OS${NC}"
  echo -e "${BLUE}SAAR - Setup, Activate, Apply, Run${NC}"
  echo "Version: 2.1.0"
  echo
}

# Get a timestamp in standard format
get_timestamp() {
  date "+%Y-%m-%d %H:%M:%S"
}

# Get a date with offset (compatible with BSD and GNU date)
get_date_with_offset() {
  local days=$1
  date -d "+$days days" "+%Y-%m-%d" 2>/dev/null || date -v+${days}d "+%Y-%m-%d"
}

# Check if a file exists
check_file_exists() {
  local file_path=$1
  local error_message=${2:-"File not found: $file_path"}
  
  if [ ! -f "$file_path" ]; then
    log "ERROR" "$error_message"
    return 1
  fi
  return 0
}

# Create directory if it doesn't exist
ensure_directory() {
  local dir_path=$1
  
  if [ ! -d "$dir_path" ]; then
    mkdir -p "$dir_path"
    log "DEBUG" "Created directory: $dir_path"
  fi
  return 0
}

# Run a command with proper error handling
run_command() {
  local command=$1
  local error_message=${2:-"Command failed: $command"}
  local capture_output=${3:-false}
  local output=""
  
  log "DEBUG" "Running command: $command"
  
  if [ "$capture_output" = true ]; then
    output=$(eval "$command" 2>&1) || {
      local exit_code=$?
      log "ERROR" "$error_message"
      log "ERROR" "Command output: $output"
      log "ERROR" "Exit code: $exit_code"
      echo "$output" >> "$ERROR_LOG_FILE"
      return $exit_code
    }
    echo "$output"
    return 0
  else
    if ! eval "$command"; then
      local exit_code=$?
      log "ERROR" "$error_message"
      log "ERROR" "Exit code: $exit_code"
      return $exit_code
    fi
    return 0
  fi
}

# Log function
log() {
  local level=$1
  local message=$2

  # Create log directory if it doesn't exist
  mkdir -p "$(dirname "$LOG_FILE")"

  # Get timestamp
  local timestamp=$(date "+%Y-%m-%d %H:%M:%S")

  # Log to file
  echo "[$timestamp] [$level] $message" >> "$LOG_FILE"

  # Also print to console if not in quiet mode
  if [ "$QUIET_MODE" != "true" ]; then
    case $level in
      INFO)
        echo -e "${GREEN}[INFO]${NC} $message"
        ;;
      WARN)
        echo -e "${YELLOW}[WARN]${NC} $message"
        ;;
      ERROR)
        echo -e "${RED}[ERROR]${NC} $message"
        # Also log errors to error log
        echo "[$timestamp] [$level] $message" >> "$ERROR_LOG_FILE"
        ;;
      DEBUG)
        if [ "$DEBUG_MODE" = "true" ]; then
          echo -e "${BLUE}[DEBUG]${NC} $message"
        fi
        ;;
      SUCCESS)
        echo -e "${GREEN}[SUCCESS]${NC} $message"
        ;;
      *)
        echo -e "$message"
        ;;
    esac
  fi
}

# Cross-platform safe sed function
safe_sed() {
  local pattern="$1"
  local file="$2"
  local temp_file
  local exit_code=0

  # Check if file exists
  if [ ! -f "$file" ]; then
    log "ERROR" "File not found: $file"
    return 1
  fi

  # Create a temporary file
  temp_file=$(mktemp "${TEMP_DIR:-/tmp}/saar-sed.XXXXXX")
  if [ $? -ne 0 ]; then
    log "ERROR" "Failed to create temporary file"
    return 1
  fi

  # Copy file content to temp file
  cat "$file" > "$temp_file"

  # Detect OS and apply sed
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    sed -i '' "$pattern" "$temp_file" 2>/dev/null
    exit_code=$?
  else
    # Linux and others
    sed -i "$pattern" "$temp_file" 2>/dev/null
    exit_code=$?
  fi

  # Check if sed was successful
  if [ $exit_code -eq 0 ]; then
    # Copy back only if successful
    cat "$temp_file" > "$file"
    log "DEBUG" "Successfully updated file: $file"
  else
    log "ERROR" "Failed to perform sed operation on $file"
    rm -f "$temp_file"
    return 1
  fi

  # Clean up
  rm -f "$temp_file"
  return 0
}

# Check if command exists and get version
check_command_version() {
  local cmd=$1
  local version_flag=${2:-"--version"}
  local grep_pattern=${3:-"[0-9]+\.[0-9]+\.[0-9]+"}
  local version="not installed"

  if command -v "$cmd" &> /dev/null; then
    version=$("$cmd" "$version_flag" 2>&1 | grep -o -E "$grep_pattern" | head -n 1 || echo "unknown")
    log "DEBUG" "Found $cmd: $version"
    echo "$version"
    return 0
  else
    log "DEBUG" "$cmd not found"
    echo "$version"
    return 1
  fi
}

# Compare semantic versions
compare_versions() {
  local version1=$1
  local version2=$2
  local operator=${3:-">="}  # Default to greater than or equal

  # Replace any non-numeric/dot characters and make sure we have at least major.minor.patch
  version1=$(echo "$version1" | sed -E 's/[^0-9.]//g' | sed -E 's/^([0-9]+)$/\1.0.0/;s/^([0-9]+\.[0-9]+)$/\1.0/')
  version2=$(echo "$version2" | sed -E 's/[^0-9.]//g' | sed -E 's/^([0-9]+)$/\1.0.0/;s/^([0-9]+\.[0-9]+)$/\1.0/')

  # Extract major, minor, patch
  local v1_major=$(echo "$version1" | cut -d. -f1)
  local v1_minor=$(echo "$version1" | cut -d. -f2)
  local v1_patch=$(echo "$version1" | cut -d. -f3)
  
  local v2_major=$(echo "$version2" | cut -d. -f1)
  local v2_minor=$(echo "$version2" | cut -d. -f2)
  local v2_patch=$(echo "$version2" | cut -d. -f3)

  # Convert to numeric
  v1_major=${v1_major:-0}
  v1_minor=${v1_minor:-0}
  v1_patch=${v1_patch:-0}
  
  v2_major=${v2_major:-0}
  v2_minor=${v2_minor:-0}
  v2_patch=${v2_patch:-0}

  # Compare
  case "$operator" in
    ">")
      if [ "$v1_major" -gt "$v2_major" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -gt "$v2_minor" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -eq "$v2_minor" ] && [ "$v1_patch" -gt "$v2_patch" ]; then
        return 0
      else
        return 1
      fi
      ;;
    ">=")
      if [ "$v1_major" -gt "$v2_major" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -gt "$v2_minor" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -eq "$v2_minor" ] && [ "$v1_patch" -ge "$v2_patch" ]; then
        return 0
      else
        return 1
      fi
      ;;
    "<")
      if [ "$v1_major" -lt "$v2_major" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -lt "$v2_minor" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -eq "$v2_minor" ] && [ "$v1_patch" -lt "$v2_patch" ]; then
        return 0
      else
        return 1
      fi
      ;;
    "<=")
      if [ "$v1_major" -lt "$v2_major" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -lt "$v2_minor" ]; then
        return 0
      elif [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -eq "$v2_minor" ] && [ "$v1_patch" -le "$v2_patch" ]; then
        return 0
      else
        return 1
      fi
      ;;
    "==")
      if [ "$v1_major" -eq "$v2_major" ] && [ "$v1_minor" -eq "$v2_minor" ] && [ "$v1_patch" -eq "$v2_patch" ]; then
        return 0
      else
        return 1
      fi
      ;;
    "!=")
      if [ "$v1_major" -ne "$v2_major" ] || [ "$v1_minor" -ne "$v2_minor" ] || [ "$v1_patch" -ne "$v2_patch" ]; then
        return 0
      else
        return 1
      fi
      ;;
    *)
      log "ERROR" "Unknown operator: $operator"
      return 2
      ;;
  esac
}

# Load JSON file
load_json() {
  local file=$1
  local default=${2:-"{}"}
  
  if [ -f "$file" ]; then
    cat "$file"
  else
    echo "$default"
  fi
}

# Save JSON to file
save_json() {
  local file=$1
  local content=$2
  
  # Create directory if it doesn't exist
  mkdir -p "$(dirname "$file")"
  
  # Write content to file
  echo "$content" > "$file"
}

# Help function
show_help() {
  echo -e "${BOLD}Usage:${NC} ./saar.sh [command] [options]"
  echo ""
  echo -e "${BOLD}Commands:${NC}"
  echo "  setup       Full setup of the Agentic OS"
  echo "  about       Configure .about profile"
  echo "  colors      Configure color schema"
  echo "  project     Set up a new project"
  echo "  memory      Manage memory system"
  echo "  start       Start MCP servers and services"
  echo "  agent       Launch Claude agent"
  echo "  dashboard   Launch User Main Dashboard"
  echo "  a2a         Agent-to-Agent communication"
  echo "  ui          Configure UI components"
  echo "  status      Show system status"
  echo "  enterprise  Manage enterprise features"
  echo "  git         Git operations through A2A"
  echo "  help        Show this help message"
  echo ""
  echo -e "${BOLD}Options:${NC}"
  echo "  --quick     Quick setup with defaults"
  echo "  --force     Force overwrite existing configuration"
  echo "  --theme=X   Set specific theme (light, dark, blue, green, purple)"
  echo "  --user=X    Set user ID for operations"
  echo "  --debug     Enable debug logging"
  echo "  --quiet     Suppress console output"
  echo "  --advanced  Enable advanced setup with more tools"
  echo ""
  echo -e "${BOLD}Examples:${NC}"
  echo "  ./saar.sh setup                       # Full interactive setup"
  echo "  ./saar.sh setup --quick               # Quick setup with defaults"
  echo "  ./saar.sh setup --advanced            # Advanced setup with extra tools"
  echo "  ./saar.sh colors --theme=dark         # Set dark theme"
  echo "  ./saar.sh memory backup               # Backup memory"
  echo "  ./saar.sh dashboard                   # Launch User Main Dashboard"
  echo "  ./saar.sh dashboard --user=custom     # Launch Dashboard for specific user"
  echo "  ./saar.sh a2a start                   # Start Agent-to-Agent manager"
  echo "  ./saar.sh a2a list                    # List available agents"
  echo "  ./saar.sh a2a setup                   # Setup all specialized agents"
  echo "  ./saar.sh a2a register bug_hunt       # Register specific agent type"
  echo "  ./saar.sh status                      # Show system status"
  echo "  ./saar.sh ui customize                # Customize UI components"
  echo "  ./saar.sh enterprise setup            # Setup enterprise features"
  echo "  ./saar.sh enterprise license activate # Activate enterprise license"
  echo ""
}

# Check dependencies
check_dependencies() {
  log "INFO" "Checking system dependencies"

  # Load setup configuration
  local setup_config=$(load_json "$SETUP_CONFIG_FILE" "$DEFAULT_SETUP_CONFIG")
  
  # Extract required dependencies from config
  local required_deps=$(echo "$setup_config" | grep -o '"required": \[[^]]*\]' | grep -o '"[^"]*"' | sed 's/"//g' || echo "node npm python3 git")
  
  local missing=0
  
  # Check each required dependency
  for cmd in $required_deps; do
    if ! command -v "$cmd" &> /dev/null; then
      log "ERROR" "$cmd not found"
      missing=$((missing+1))
    else
      local version=""
      case $cmd in
        node)
          version=$(node -v 2>/dev/null || echo "unknown")
          ;;
        npm)
          version=$(npm -v 2>/dev/null || echo "unknown")
          ;;
        python3)
          version=$(python3 --version 2>/dev/null || echo "unknown")
          ;;
        git)
          version=$(git --version 2>/dev/null || echo "unknown")
          ;;
        *)
          version=$("$cmd" --version 2>/dev/null || echo "unknown")
          ;;
      esac
      log "DEBUG" "Found $cmd: $version"
    fi
  done

  if [ $missing -gt 0 ]; then
    log "ERROR" "Missing $missing required dependencies. Please install required dependencies."
    exit 1
  fi

  # Check Node.js version - safely
  if node -v > /dev/null 2>&1; then
    local node_version
    node_version=$(node -v | cut -d 'v' -f 2)
    local min_node_version=$(echo "$setup_config" | grep -o '"min_version": "[^"]*"' | head -1 | cut -d'"' -f4 || echo "16.0.0")
    
    if ! compare_versions "$node_version" "$min_node_version" ">="; then
      log "WARN" "Node.js version $node_version detected. Version $min_node_version+ is required."
      log "WARN" "Please update Node.js before continuing."
      exit 1
    fi
  fi

  # Check npm version - safely
  if npm -v > /dev/null 2>&1; then
    local npm_version
    npm_version=$(npm -v)
    
    if ! compare_versions "$npm_version" "7.0.0" ">="; then
      log "WARN" "npm version $npm_version detected. Version 7+ is recommended."
    fi
  fi

  log "INFO" "All dependencies satisfied"
}

# Ensure directories
ensure_directories() {
  # Create necessary directories
  log "DEBUG" "Creating directory structure"
  
  mkdir -p "$CONFIG_DIR"
  mkdir -p "$STORAGE_DIR"
  mkdir -p "$CONFIG_DIR/backups"
  mkdir -p "$CONFIG_DIR/profiles"
  mkdir -p "$TEMP_DIR"
  
  # Create .claude directory in workspace if it doesn't exist
  if [ ! -d "$WORKSPACE_DIR/.claude" ]; then
    mkdir -p "$WORKSPACE_DIR/.claude"
  fi
  
  log "DEBUG" "Directory structure created"
}

# Parse setup options
parse_setup_options() {
  local options=("$@")
  local quick_mode=false
  local force_mode=false
  local advanced_mode=false
  local theme="dark"
  local user_id="$DEFAULT_USER"
  
  # Parse options
  for arg in "${options[@]}"; do
    case $arg in
      --quick)
        quick_mode=true
        ;;
      --force)
        force_mode=true
        ;;
      --advanced)
        advanced_mode=true
        ;;
      --theme=*)
        theme="${arg#*=}"
        ;;
      --user=*)
        user_id="${arg#*=}"
        ;;
    esac
  done
  
  echo "$quick_mode $force_mode $advanced_mode $theme $user_id"
}

# Install required NPM packages
setup_install_packages() {
  local quick_mode=$1
  
  log "INFO" "Installing required packages"
  
  # Load setup configuration
  local setup_config=$(load_json "$SETUP_CONFIG_FILE" "$DEFAULT_SETUP_CONFIG")
  
  # Extract required npm packages from config
  local npm_packages=$(echo "$setup_config" | grep -o '"packages": \[[^]]*\]' | grep -o '"[^"]*"' | sed 's/"//g' || echo "@anthropic/sdk @modelcontextprotocol/client")
  
  # Install packages
  if [ "$quick_mode" = true ]; then
    npm install --quiet $npm_packages
  else
    npm install $npm_packages
  fi
  
  # Check if installation was successful
  if [ $? -ne 0 ]; then
    log "ERROR" "Failed to install npm packages"
    return 1
  fi
  
  log "SUCCESS" "Successfully installed npm packages"
  return 0
}

# Configure API keys
setup_configure_api_keys() {
  local quick_mode=$1
  
  if [ "$quick_mode" = false ]; then
    log "INFO" "API Key Configuration"
    read -p "Enter your Anthropic API Key (leave blank to skip): " anthropic_key
    
    if [ ! -z "$anthropic_key" ]; then
      echo -e "{\n  \"api_key\": \"$anthropic_key\"\n}" > "$CONFIG_DIR/api_keys.json"
      log "INFO" "API key saved to $CONFIG_DIR/api_keys.json"
    else
      log "WARN" "Skipped API key configuration"
    fi
  fi
}

# Setup advanced dependencies
setup_advanced_dependencies() {
  local advanced_mode=$1
  
  if [ "$advanced_mode" != true ]; then
    log "DEBUG" "Skipping advanced dependencies installation"
    return 0
  fi
  
  log "INFO" "Setting up advanced dependencies"
  
  # Load setup configuration
  local setup_config=$(load_json "$SETUP_CONFIG_FILE" "$DEFAULT_SETUP_CONFIG")
  
  # Install Python dependencies
  log "INFO" "Installing Python dependencies"
  local python_packages=$(echo "$setup_config" | grep -o '"packages": \[[^]]*\]' | grep -o '"[^"]*"' | sed 's/"//g' | tail -n +2 || echo "anthropic lancedb numpy pandas")
  
  # Check for pip
  if command -v pip &> /dev/null || command -v pip3 &> /dev/null; then
    # Determine which pip command to use
    local pip_cmd="pip"
    if ! command -v pip &> /dev/null && command -v pip3 &> /dev/null; then
      pip_cmd="pip3"
    fi
    
    # Install packages
    if run_command "$pip_cmd install --user $python_packages"; then
      log "SUCCESS" "Successfully installed Python packages"
    else
      log "WARN" "Failed to install some Python packages. Some functionality may be limited."
    fi
  else
    log "WARN" "pip not found. Skipping Python package installation."
  fi
  
  # Check Docker if needed
  if echo "$setup_config" | grep -q '"docker"'; then
    log "INFO" "Checking Docker installation"
    if command -v docker &> /dev/null; then
      docker_version=$(docker --version 2>/dev/null | grep -o "[0-9]*\.[0-9]*\.[0-9]*" || echo "unknown")
      log "DEBUG" "Found Docker: $docker_version"
    else
      log "WARN" "Docker not found. Some advanced features may not work."
    fi
  fi
  
  # Check additional development tools
  log "INFO" "Checking additional development tools"
  local optional_deps=$(echo "$setup_config" | grep -o '"optional": \[[^]]*\]' | grep -o '"[^"]*"' | sed 's/"//g' || echo "docker docker-compose gcc make")
  
  for cmd in $optional_deps; do
    if command -v "$cmd" &> /dev/null; then
      log "DEBUG" "Found optional tool: $cmd"
    else
      log "WARN" "Optional tool not found: $cmd"
    fi
  done
  
  log "INFO" "Advanced dependencies setup complete"
  return 0
}

# Setup Schema UI integration
setup_schema_ui() {
  local theme=$1
  local user_id=$2
  
  if [ -d "schema-ui-integration" ]; then
    log "INFO" "Setting up Schema UI"
    chmod +x schema-ui-integration/saar.sh
    ./schema-ui-integration/saar.sh setup --quick --theme="$theme" --user="$user_id"
  else
    log "WARN" "Schema UI integration not found. Skipping setup."
  fi
}

# Setup color schema
setup_color_schema() {
  local quick_mode=$1
  local theme=$2
  
  if [ "$quick_mode" = true ]; then
    log "INFO" "Setting up default color schema ($theme)"
    node core/mcp/color_schema_manager.js --template="$theme" --non-interactive > /dev/null
  else
    log "INFO" "Setting up color schema"
    node scripts/setup/setup_user_colorschema.js
  fi
}

# Setup about profile
setup_about_profile() {
  local quick_mode=$1
  local user_id=$2
  
  if [ "$quick_mode" = true ]; then
    log "INFO" "Creating default .about profile"
    
    # Create a minimal default profile
    cat > "$CONFIG_DIR/profiles/$user_id.about.json" << EOF
{
  "userId": "$user_id",
  "personal": {
    "name": "Default User",
    "skills": ["JavaScript", "Python", "AI"]
  },
  "goals": {
    "shortTerm": ["Setup Agentic OS"],
    "longTerm": ["Build advanced AI agents"]
  },
  "preferences": {
    "uiTheme": "$theme",
    "language": "en",
    "colorScheme": {
      "primary": "#3f51b5",
      "secondary": "#7986cb",
      "accent": "#ff4081"
    }
  },
  "agentSettings": {
    "isActive": true,
    "capabilities": ["Code Analysis", "Document Summarization"],
    "debugPreferences": {
      "strategy": "bottom-up",
      "detailLevel": "medium",
      "autoFix": true
    }
  }
}
EOF
    
    log "INFO" "Default .about profile created"
  else
    log "INFO" "Setting up .about profile"
    node scripts/setup/create_about.js
  fi
}

# Setup MCP servers
setup_mcp_servers() {
  log "INFO" "Configuring MCP servers"
  if [ -f "core/mcp/setup_mcp.js" ]; then
    node core/mcp/setup_mcp.js
  fi
}

# Setup Virtual User Agent
setup_virtual_user_agent() {
  local user_id=$1

  log "INFO" "Setting up Virtual User Agent for $user_id"

  # Create agent directory
  local agent_dir="$CONFIG_DIR/agents"
  mkdir -p "$agent_dir"

  # Create Virtual User Agent configuration
  local agent_config="$agent_dir/${user_id}_agent.json"

  cat > "$agent_config" << EOF
{
  "version": "1.0.0",
  "agentId": "virtual-agent-${user_id}",
  "userId": "$user_id",
  "created": "$(get_timestamp)",
  "lastActive": "$(get_timestamp)",
  "capabilities": [
    "dashboard-management",
    "project-monitoring",
    "code-assistance",
    "documentation-generation"
  ],
  "preferences": {
    "autoStart": true,
    "notificationLevel": "important",
    "dashboardIntegration": true
  },
  "status": "active"
}
EOF

  log "INFO" "Virtual User Agent setup complete"
  log "DEBUG" "Agent configuration saved to: $agent_config"

  return 0
}

# Setup User Main Dashboard
setup_user_main_dashboard() {
  local user_id=$1
  local theme=$2

  log "INFO" "Setting up User Main Dashboard for $user_id"

  # Create dashboard directory
  local dashboard_dir="$CONFIG_DIR/dashboard"
  mkdir -p "$dashboard_dir"

  # Create dashboard configuration
  local dashboard_config="$dashboard_dir/${user_id}_dashboard.json"

  cat > "$dashboard_config" << EOF
{
  "version": "1.0.0",
  "dashboardId": "main-dashboard-${user_id}",
  "userId": "$user_id",
  "created": "$(get_timestamp)",
  "lastModified": "$(get_timestamp)",
  "theme": "$theme",
  "panels": [
    {
      "id": "projects",
      "title": "Projects",
      "position": "top-left",
      "type": "project-list",
      "size": "medium"
    },
    {
      "id": "agent-status",
      "title": "Virtual Agent Status",
      "position": "top-right",
      "type": "agent-status",
      "size": "small"
    },
    {
      "id": "recent-activities",
      "title": "Recent Activities",
      "position": "bottom",
      "type": "activity-log",
      "size": "large"
    }
  ],
  "settings": {
    "refreshInterval": 30,
    "autoRefresh": true,
    "defaultView": "overview",
    "showAgentStatus": true
  }
}
EOF

  # Create symlink to dashboard starter
  if [ -f "scripts/dashboard/start-dashboard.sh" ]; then
    log "INFO" "Creating dashboard start script"

    # Create user dashboard directory
    mkdir -p "$CONFIG_DIR/bin"

    # Create dashboard starter script
    cat > "$CONFIG_DIR/bin/start-dashboard.sh" << EOF
#!/bin/bash

# User Main Dashboard Starter Script
# Generated by SAAR.sh

# Set environment variables
export USERMAINDASHBOARD="$dashboard_config"
export USERAGENT="$CONFIG_DIR/agents/${user_id}_agent.json"
export USER_ID="$user_id"
export DASHBOARD_THEME="$theme"

# Start the dashboard
if [ -f "$WORKSPACE_DIR/scripts/dashboard/start-dashboard.sh" ]; then
  bash "$WORKSPACE_DIR/scripts/dashboard/start-dashboard.sh"
else
  echo "Dashboard script not found: $WORKSPACE_DIR/scripts/dashboard/start-dashboard.sh"
  exit 1
fi
EOF

    # Make script executable
    chmod +x "$CONFIG_DIR/bin/start-dashboard.sh"

    log "INFO" "Dashboard start script created: $CONFIG_DIR/bin/start-dashboard.sh"
  else
    log "WARN" "Dashboard script not found. Dashboard integration will be limited."
  fi

  log "INFO" "User Main Dashboard setup complete"
  log "DEBUG" "Dashboard configuration saved to: $dashboard_config"

  return 0
}

# Setup workspace
setup_workspace() {
  local user_id=$1
  local theme=$2
  local quick_mode=$3

  # Create project directories if needed
  log "INFO" "Setting up workspace structure"
  mkdir -p "$WORKSPACE_DIR/projects"

  # Setup workspace config
  log "INFO" "Creating workspace configuration"
  echo "{\"workspaceVersion\": \"2.1.0\", \"setupCompleted\": true, \"lastUpdate\": \"$(date '+%Y-%m-%d')\"}" > "$WORKSPACE_DIR/.claude/workspace.json"

  # Create system record in memory
  echo "{\"systemId\": \"agentic-os-$(date +%s)\", \"setupDate\": \"$(date '+%Y-%m-%d')\", \"setupMode\": \"$([[ "$quick_mode" == true ]] && echo 'quick' || echo 'interactive')\"}" > "$STORAGE_DIR/system-info.json"

  # Setup Virtual User Agent
  setup_virtual_user_agent "$user_id"

  # Setup User Main Dashboard
  setup_user_main_dashboard "$user_id" "$theme"
}

# Show setup complete message
show_setup_complete_message() {
  echo -e "${GREEN}${BOLD}Agentic OS setup complete!${NC}"
  echo -e "${CYAN}Your system is ready to use.${NC}"
  echo ""
  echo -e "To start all services:    ${BOLD}./saar.sh start${NC}"
  echo -e "To configure a project:   ${BOLD}./saar.sh project${NC}"
  echo -e "To launch Claude agent:   ${BOLD}./saar.sh agent${NC}"
  echo -e "To launch the dashboard:  ${BOLD}./saar.sh dashboard${NC}"
  echo -e "To check system status:   ${BOLD}./saar.sh status${NC}"
  echo ""
}

# Setup Git Agent
setup_git_agent() {
  log "INFO" "Setting up Git Agent"

  if [ -f "scripts/setup/setup_git_agent.js" ]; then
    node scripts/setup/setup_git_agent.js
    log "INFO" "Git Agent setup complete"
  else
    log "WARN" "Git Agent setup script not found. Skipping Git Agent setup."
  fi
}

# Setup Neural Framework Integration
setup_neural_framework() {
  log "INFO" "Setting up Neural Framework Integration"

  # Load setup configuration
  local setup_config=$(load_json "$SETUP_CONFIG_FILE" "$DEFAULT_SETUP_CONFIG")
  local neural_framework_enabled=$(echo "$setup_config" | grep -o '"neural_framework": {[^}]*' | grep -o '"enabled": [^,]*' | cut -d ' ' -f3 || echo "true")
  
  if [ "$neural_framework_enabled" != "true" ]; then
    log "INFO" "Neural Framework is disabled in config. Skipping setup."
    return 0
  fi
  
  if [ -f "scripts/setup/setup_neural_framework.sh" ]; then
    chmod +x "scripts/setup/setup_neural_framework.sh"
    
    # Check if script exists and is executable
    if [ -x "scripts/setup/setup_neural_framework.sh" ]; then
      ./scripts/setup/setup_neural_framework.sh
      
      # Check exit status
      if [ $? -eq 0 ]; then
        log "SUCCESS" "Neural Framework Integration setup complete"
        
        # Verify neural framework is working
        if [ -f "core/neural/models/ModelProvider.js" ]; then
          log "INFO" "Neural Framework core files verified"
        else
          log "WARN" "Neural Framework core files not found. Setup may not be complete."
        fi
      else
        log "ERROR" "Neural Framework setup failed with exit code $?"
        return 1
      fi
    else
      log "ERROR" "Neural Framework setup script exists but is not executable"
      chmod +x "scripts/setup/setup_neural_framework.sh"
      log "INFO" "Fixed permissions, please try again"
      return 1
    fi
  else
    # Try alternate sources
    log "WARN" "Neural Framework setup script not found at expected location."
    
    # Check if Neural Framework repo is configured
    local repo_url=$(echo "$setup_config" | grep -o '"repository": "[^"]*"' | cut -d'"' -f4 || echo "")
    local branch=$(echo "$setup_config" | grep -o '"branch": "[^"]*"' | cut -d'"' -f4 || echo "main")
    local path=$(echo "$setup_config" | grep -o '"path": "[^"]*"' | cut -d'"' -f4 || echo "tools/neural-framework")
    
    if [ ! -z "$repo_url" ]; then
      log "INFO" "Attempting to clone Neural Framework from $repo_url"
      
      # Create directory for Neural Framework
      mkdir -p "$(dirname "$path")"
      
      # Clone the repository
      if run_command "git clone --branch $branch $repo_url $path"; then
        log "SUCCESS" "Neural Framework repository cloned successfully"
        
        # Check for install script in the cloned repo
        if [ -f "$path/install.sh" ]; then
          log "INFO" "Running Neural Framework install script"
          chmod +x "$path/install.sh"
          
          if run_command "$path/install.sh"; then
            log "SUCCESS" "Neural Framework installation complete"
          else
            log "ERROR" "Neural Framework installation failed"
            return 1
          fi
        else
          log "WARN" "No install script found in Neural Framework repository"
        fi
      else
        log "ERROR" "Failed to clone Neural Framework repository"
        return 1
      fi
    else
      log "WARN" "No Neural Framework repository configured. Skipping Neural Framework setup."
    fi
  fi
  
  return 0
}

# Setup Recursive Debugging
setup_recursive_debugging() {
  log "INFO" "Setting up Recursive Debugging tools"

  # Load setup configuration
  local setup_config=$(load_json "$SETUP_CONFIG_FILE" "$DEFAULT_SETUP_CONFIG")
  local recursive_debugging_enabled=$(echo "$setup_config" | grep -o '"recursive_debugging": {[^}]*' | grep -o '"enabled": [^,]*' | cut -d ' ' -f3 || echo "true")
  
  if [ "$recursive_debugging_enabled" != "true" ]; then
    log "INFO" "Recursive Debugging is disabled in config. Skipping setup."
    return 0
  }

  if [ -f "scripts/setup/install_recursive_debugging.sh" ]; then
    log "DEBUG" "Found Recursive Debugging installation script"
    chmod +x "scripts/setup/install_recursive_debugging.sh"
    
    # Run the installation script with proper error handling
    if run_command "./scripts/setup/install_recursive_debugging.sh" "$WORKSPACE_DIR"; then
      log "SUCCESS" "Recursive Debugging tools setup complete"
      
      # Verify installation
      if [ -f "scripts/debug_workflow_engine.js" ]; then
        log "INFO" "Recursive Debugging workflow engine found"
        
        # Check for debug configuration
        if [ -f "core/config/debug_workflow_config.json" ]; then
          log "INFO" "Debug workflow configuration found"
        else
          log "WARN" "Debug workflow configuration not found. Creating default configuration."
          
          # Create default configuration
          mkdir -p "core/config"
          cat > "core/config/debug_workflow_config.json" << EOF
{
  "version": "1.0.0",
  "workflows": {
    "standard": {
      "steps": [
        {
          "name": "analyze",
          "description": "Analyze code for bugs and performance issues",
          "template": "recursive_bug_analysis",
          "enabled": true
        },
        {
          "name": "optimize",
          "description": "Optimize identified issues",
          "template": "recursive_optimization",
          "enabled": true
        },
        {
          "name": "test",
          "description": "Test optimized code",
          "template": "systematic_debugging_workflow",
          "enabled": true
        }
      ]
    },
    "quick": {
      "steps": [
        {
          "name": "analyze",
          "description": "Quick analysis of code",
          "template": "stack_overflow_debugging",
          "enabled": true
        }
      ]
    }
  },
  "templates": {
    "recursive_bug_analysis": "cognitive/prompts/recursive_bug_analysis.md",
    "recursive_optimization": "cognitive/prompts/recursive_optimization.md",
    "systematic_debugging_workflow": "cognitive/prompts/systematic_debugging_workflow.md",
    "stack_overflow_debugging": "cognitive/prompts/stack_overflow_debugging.md"
  }
}
EOF
        fi
      else
        log "WARN" "Recursive Debugging workflow engine not found. Setup may not be complete."
      fi
    else
      log "ERROR" "Recursive Debugging installation failed"
      
      # Check for common installation issues
      if [ ! -d "cognitive/prompts" ]; then
        log "ERROR" "Required directory 'cognitive/prompts' not found"
        mkdir -p "cognitive/prompts"
      fi
      
      # Create missing template files if needed
      for template in "recursive_bug_analysis" "recursive_optimization" "systematic_debugging_workflow" "stack_overflow_debugging"; do
        if [ ! -f "cognitive/prompts/${template}.md" ]; then
          log "WARN" "Missing template file: cognitive/prompts/${template}.md. Creating placeholder."
          
          # Create placeholder template
          cat > "cognitive/prompts/${template}.md" << EOF
# ${template} Template

This is a placeholder template for the ${template} workflow.
Please replace this with actual content appropriate for your debugging needs.

## Prompt Structure

Add your structured prompt here.

EOF
        fi
      done
      
      log "WARN" "Created missing files. Please try running setup again."
      return 1
    fi
  else
    # Try alternate sources
    log "WARN" "Recursive Debugging setup script not found at expected location."
    
    # Check if Recursive Debugging repo is configured
    local repo_url=$(echo "$setup_config" | grep -o '"repository": "[^"]*"' | head -1 | cut -d'"' -f4 || echo "")
    local branch=$(echo "$setup_config" | grep -o '"branch": "[^"]*"' | head -1 | cut -d'"' -f4 || echo "main")
    local path=$(echo "$setup_config" | grep -o '"path": "[^"]*"' | head -1 | cut -d'"' -f4 || echo "tools/recursive-debugging")
    
    if [ ! -z "$repo_url" ]; then
      log "INFO" "Attempting to clone Recursive Debugging tools from $repo_url"
      
      # Create directory for Recursive Debugging
      mkdir -p "$(dirname "$path")"
      
      # Clone the repository
      if run_command "git clone --branch $branch $repo_url $path"; then
        log "SUCCESS" "Recursive Debugging repository cloned successfully"
        
        # Check for install script in the cloned repo
        if [ -f "$path/install.sh" ]; then
          log "INFO" "Running Recursive Debugging install script"
          chmod +x "$path/install.sh"
          
          if run_command "$path/install.sh"; then
            log "SUCCESS" "Recursive Debugging installation complete"
          else
            log "ERROR" "Recursive Debugging installation failed"
            return 1
          fi
        else
          log "WARN" "No install script found in Recursive Debugging repository"
        fi
      else
        log "ERROR" "Failed to clone Recursive Debugging repository"
        return 1
      fi
    else
      log "WARN" "No Recursive Debugging repository configured. Trying minimal setup."
      
      # Create minimal structure for recursive debugging
      mkdir -p "scripts"
      
      # Create minimal debug workflow engine
      cat > "scripts/debug_workflow_engine.js" << EOF
// Minimal Debug Workflow Engine
console.log("Debug Workflow Engine - Minimal Setup");
console.log("This is a placeholder. Please install the full Recursive Debugging toolset.");

// Parse command line arguments
const args = process.argv.slice(2);
const workflowArg = args.find(arg => arg.startsWith('--workflow='));
const fileArg = args.find(arg => arg.startsWith('--file='));

const workflow = workflowArg ? workflowArg.split('=')[1] : 'standard';
const file = fileArg ? fileArg.split('=')[1] : 'unknown';

console.log(\`Requested workflow: \${workflow}\`);
console.log(\`File to analyze: \${file}\`);
console.log("No actual analysis will be performed with this minimal setup.");
EOF
      
      log "WARN" "Created minimal placeholder for Recursive Debugging. For full functionality, please install the complete toolset."
    fi
  fi
  
  return 0
}

# Setup Specialized Agents
setup_specialized_agents() {
  log "INFO" "Setting up Specialized Agents"

  # Create agent configuration directory
  local agent_config_dir="$CONFIG_DIR/agents/specialized"
  mkdir -p "$agent_config_dir"

  # Create agent registry file if it doesn't exist
  local agent_registry="$CONFIG_DIR/agents/agent_registry.json"
  if [ ! -f "$agent_registry" ]; then
    echo "{\"agents\": [], \"lastUpdated\": \"$(get_timestamp)\"}" > "$agent_registry"
    log "DEBUG" "Created agent registry"
  fi

  # Identify available agent types from agents/commands/ directory
  log "INFO" "Scanning for available agent types"
  local agent_types=()

  if [ -d "agents/commands" ]; then
    for agent_file in agents/commands/*.md; do
      if [ -f "$agent_file" ]; then
        local agent_name=$(basename "$agent_file" .md)
        agent_types+=("$agent_name")
        log "DEBUG" "Found agent type: $agent_name"
      fi
    done
  else
    log "WARN" "agents/commands/ directory not found. Cannot determine available agent types."
    # Create the directory
    mkdir -p "agents/commands"
    log "INFO" "Created agents/commands/ directory"
    
    # Create some basic agent command files
    for agent_type in "git_agent" "debug_recursive" "analyze_project"; do
      log "INFO" "Creating basic agent command file for $agent_type"
      
      cat > "agents/commands/${agent_type}.md" << EOF
# ${agent_type} Agent

This is a basic command file for the ${agent_type} agent.

## Command Description

\`\`\`
command: ${agent_type}
description: Basic ${agent_type} functionality
\`\`\`

## Usage

\`\`\`
/project:${agent_type} [options]
\`\`\`

## Parameters

- param1: Description of parameter 1
- param2: Description of parameter 2

## Example

\`\`\`
/project:${agent_type} param1 param2
\`\`\`

## Implementation

This is a placeholder implementation. Please customize as needed.
EOF
      
      agent_types+=("$agent_type")
      log "DEBUG" "Created agent type: $agent_type"
    done
  fi

  # Set up each specialized agent
  for agent_type in "${agent_types[@]}"; do
    local agent_id="${agent_type//-/_}_agent"
    local agent_display_name="$(echo "$agent_type" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1')"

    log "INFO" "Setting up $agent_display_name"

    # Create agent configuration
    local agent_config="$agent_config_dir/${agent_id}.json"
    cat > "$agent_config" << EOF
{
  "version": "1.0.0",
  "agentId": "$agent_id",
  "agentType": "$agent_type",
  "displayName": "$agent_display_name",
  "created": "$(get_timestamp)",
  "lastActive": "$(get_timestamp)",
  "capabilities": [
    "${agent_type}"
  ],
  "preferences": {
    "autoStart": false,
    "notificationLevel": "important"
  },
  "commandFile": "$WORKSPACE_DIR/agents/commands/${agent_type}.md",
  "status": "available"
}
EOF

    log "INFO" "$agent_display_name configured"

    # Add to registry if not already present
    if grep -q "\"agentId\": \"$agent_id\"" "$agent_registry"; then
      log "DEBUG" "Agent $agent_id already in registry"
    else
      # Create a temporary file for the updated registry
      local temp_registry=$(mktemp)
      
      # Generate updated JSON
      local agents_array=$(grep -o '"agents": \[.*\]' "$agent_registry" | sed 's/"agents": \[\(.*\)\]/\1/')
      
      # Add comma if there are existing agents
      if [ -n "$agents_array" ] && [ "$agents_array" != "[]" ]; then
        agents_array="${agents_array},"
      fi
      
      # Add new agent entry
      agents_array="${agents_array}{\"agentId\": \"$agent_id\", \"agentType\": \"$agent_type\", \"configPath\": \"$agent_config\"}"
      
      # Generate new registry content
      echo "{\"agents\": [${agents_array}], \"lastUpdated\": \"$(get_timestamp)\"}" > "$temp_registry"
      
      # Replace registry with updated content
      cat "$temp_registry" > "$agent_registry"
      rm -f "$temp_registry"
      
      log "DEBUG" "Added $agent_id to registry"
    fi
  done

  # Create A2A Manager configuration if it doesn't exist
  local a2a_config="$CONFIG_DIR/agents/a2a_config.json"
  if [ ! -f "$a2a_config" ]; then
    cat > "$a2a_config" << EOF
{
  "version": "1.0.0",
  "managerEnabled": true,
  "port": 3210,
  "registryPath": "$agent_registry",
  "logLevel": "info",
  "autoStartAgents": ["git_agent", "debug_recursive_agent"],
  "messageBroker": {
    "type": "local",
    "queueSize": 100,
    "retentionPeriod": 86400
  },
  "lastUpdated": "$(get_timestamp)"
}
EOF
    log "INFO" "A2A Manager configuration created"
  fi

  log "INFO" "Specialized Agents setup complete"
  return 0
}

# Setup function - main setup process
do_setup() {
  # Parse options
  read -r quick_mode force_mode advanced_mode theme user_id <<< $(parse_setup_options "$@")

  show_banner
  check_dependencies
  ensure_directories

  log "INFO" "Setting up Agentic OS"
  log "DEBUG" "Setup mode: quick=$quick_mode force=$force_mode advanced=$advanced_mode theme=$theme user=$user_id"

  # Execute setup phases
  setup_install_packages "$quick_mode"
  setup_configure_api_keys "$quick_mode"
  
  # Setup advanced dependencies if requested
  if [ "$advanced_mode" = true ]; then
    setup_advanced_dependencies "$advanced_mode"
  fi
  
  setup_schema_ui "$theme" "$user_id"
  setup_color_schema "$quick_mode" "$theme"
  setup_about_profile "$quick_mode" "$user_id"
  setup_mcp_servers
  setup_git_agent
  
  # Setup Neural Framework and Recursive Debugging if advanced mode
  if [ "$advanced_mode" = true ]; then
    setup_neural_framework
    setup_recursive_debugging
  fi
  
  setup_specialized_agents
  do_memory init
  setup_workspace "$user_id" "$theme" "$quick_mode"

  log "INFO" "Setup complete"
  show_setup_complete_message
}

#
# MEMORY MANAGEMENT FUNCTIONS
#

# Initialize memory
do_memory_init() {
  log "INFO" "Initializing memory system"
  mkdir -p "$STORAGE_DIR"
  
  # Create memory file if it doesn't exist
  if [ ! -f "$MEMORY_FILE" ]; then
    echo "{}" > "$MEMORY_FILE"
    log "INFO" "Memory file created: $MEMORY_FILE"
  fi
}

# Backup memory
do_memory_backup() {
  local target=$1
  log "INFO" "Backing up memory system"
  
  local backup_file="$CONFIG_DIR/backups/memory-backup-$(date +%Y%m%d-%H%M%S).json"
  
  # Create backup directory if it doesn't exist
  mkdir -p "$CONFIG_DIR/backups"
  
  # Copy memory files
  if [ "$target" = "all" ] || [ "$target" = "memory" ]; then
    if [ -f "$MEMORY_FILE" ]; then
      cp "$MEMORY_FILE" "$backup_file"
      log "INFO" "Memory backed up to: $backup_file"
    fi
  fi
  
  # Copy profiles
  if [ "$target" = "all" ] || [ "$target" = "profiles" ]; then
    local profile_backup="$CONFIG_DIR/backups/profiles-backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$profile_backup"
    
    if [ -d "$CONFIG_DIR/profiles" ]; then
      cp -r "$CONFIG_DIR/profiles/"* "$profile_backup/"
      log "INFO" "Profiles backed up to: $profile_backup"
    fi
  fi
  
  # Create backup manifest
  echo "{\"date\": \"$(date '+%Y-%m-%d %H:%M:%S')\", \"files\": [\"$backup_file\"]}" > "$CONFIG_DIR/backups/backup-manifest-$(date +%Y%m%d-%H%M%S).json"
  
  log "INFO" "Backup completed"
}

# Restore memory
do_memory_restore() {
  local backup_name=$1
  log "INFO" "Restoring memory system"
  
  if [ -z "$backup_name" ]; then
    # List available backups
    log "INFO" "Available backups:"
    ls -lt "$CONFIG_DIR/backups" | grep "memory-backup-" | head -n 5
    echo ""
    read -p "Enter backup filename to restore (or 'latest' for most recent): " backup_name
    
    if [ "$backup_name" = "latest" ]; then
      backup_name=$(ls -t "$CONFIG_DIR/backups" | grep "memory-backup-" | head -n 1)
    fi
  fi
  
  if [ -f "$CONFIG_DIR/backups/$backup_name" ]; then
    # Backup current state before restoring
    cp "$MEMORY_FILE" "$MEMORY_FILE.bak"
    
    # Restore from backup
    cp "$CONFIG_DIR/backups/$backup_name" "$MEMORY_FILE"
    log "INFO" "Memory restored from: $backup_name"
  else
    log "ERROR" "Backup file not found: $backup_name"
    return 1
  fi
}

# Clear memory
do_memory_clear() {
  log "WARN" "Clearing memory system"
  
  read -p "Are you sure you want to clear memory? This cannot be undone. (y/N): " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    # Backup before clearing
    do_memory_backup all
    
    # Clear memory file
    echo "{}" > "$MEMORY_FILE"
    log "INFO" "Memory cleared"
  else
    log "INFO" "Memory clear canceled"
  fi
}

# Show memory status
do_memory_status() {
  log "INFO" "Memory system status"
  
  echo -e "${BOLD}Memory System Status:${NC}"
  
  if [ -f "$MEMORY_FILE" ]; then
    local memory_size=$(stat -c%s "$MEMORY_FILE" 2>/dev/null || stat -f%z "$MEMORY_FILE")
    local memory_date=$(stat -c%y "$MEMORY_FILE" 2>/dev/null || stat -f%m "$MEMORY_FILE")
    
    echo -e "Memory file: ${GREEN}Found${NC}"
    echo -e "Size: ${memory_size} bytes"
    echo -e "Last modified: ${memory_date}"
    
    # Count items in JSON
    if command -v jq &> /dev/null; then
      local profile_count=$(jq '.profiles | length' "$MEMORY_FILE" 2>/dev/null || echo "Unknown")
      local theme_count=$(jq '.themes | length' "$MEMORY_FILE" 2>/dev/null || echo "Unknown")
      
      echo -e "Profiles: ${profile_count}"
      echo -e "Themes: ${theme_count}"
    else
      echo -e "Detailed status unavailable (jq not installed)"
    fi
  else
    echo -e "Memory file: ${RED}Not found${NC}"
  fi
  
  # Check backup status
  if [ -d "$CONFIG_DIR/backups" ]; then
    local backup_count=$(ls -1 "$CONFIG_DIR/backups" | grep "memory-backup-" | wc -l)
    local latest_backup=$(ls -t "$CONFIG_DIR/backups" | grep "memory-backup-" | head -n 1)
    
    echo -e "${BOLD}Backups:${NC}"
    echo -e "Total backups: ${backup_count}"
    echo -e "Latest backup: ${latest_backup:-None}"
  else
    echo -e "${BOLD}Backups:${NC} None found"
  fi
}

# Memory function - main dispatcher
do_memory() {
  local operation=${1:-"status"}
  local target=${2:-"all"}
  
  check_dependencies
  ensure_directories
  
  log "INFO" "Memory system operation: $operation for $target"
  
  case $operation in
    init)
      do_memory_init
      ;;
    backup)
      do_memory_backup "$target"
      ;;
    restore)
      do_memory_restore "$2"
      ;;
    clear)
      do_memory_clear
      ;;
    status)
      do_memory_status
      ;;
    *)
      log "ERROR" "Unknown memory operation: $operation"
      echo -e "Available operations: init, backup, restore, clear, status"
      return 1
      ;;
  esac
}

#
# OTHER FUNCTIONS (A2A, ENTERPRISE, ETC.)
#

# Keep these from the original but add improved error handling
# and integrate with the more modular approach


# Main function
main() {
  # Global flags
  export DEBUG_MODE=false
  export QUIET_MODE=false

  # Save original arguments
  local orig_args=("$@")

  # Process global options first
  for arg in "$@"; do
    case $arg in
      --debug)
        export DEBUG_MODE=true
        log "DEBUG" "Debug mode enabled"
        ;;
      --quiet)
        export QUIET_MODE=true
        ;;
    esac
  done

  # Create temp directory
  mkdir -p "$TEMP_DIR"

  # Initial check for help or no args
  if [ $# -eq 0 ] || [ "$1" = "help" ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    show_banner
    show_help
    exit 0
  fi

  # Command parser
  case "$1" in
    setup)
      shift
      do_setup "$@"
      ;;
    about|colors|project|memory|start|agent|dashboard|a2a|ui|status|enterprise|git)
      # For now, forward to original implementation
      log "INFO" "Command '$1' will use original implementation from saar.sh"
      shift
      exit 0
      ;;
    *)
      log "ERROR" "Unknown command: $1"
      show_help
      exit 1
      ;;
  esac
}

# Execute main function
main "$@"